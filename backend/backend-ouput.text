import { Request, Response } from 'express';
import { Cita } from '../models/cita.model';
import { CitaEmpleado } from '../models/cita-empleado.model';

export class CitaController {
    // Obtener todas las citas
    public async obtenerCitas(req: Request, res: Response): Promise<void> {
        try {
            const citas = await Cita.findAll({
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });
            res.status(200).json({
                success: true,
                data: citas,
                message: 'Citas obtenidas exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener las citas',
                error: error
            });
        }
    }

    // Obtener una cita por ID
    public async obtenerCitaPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const cita = await Cita.findByPk(id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });
            
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: cita,
                message: 'Cita obtenida exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener la cita',
                error: error
            });
        }
    }

    // Crear una nueva cita
    public async crearCita(req: Request, res: Response): Promise<void> {
        try {
            const { empleadosIds, ...citaData } = req.body;
            const nuevaCita = await Cita.create(citaData);

            // Crear las relaciones con empleados si se proporcionaron
            if (empleadosIds && Array.isArray(empleadosIds)) {
                const citaEmpleados = empleadosIds.map(empleadoId => ({
                    citaId: nuevaCita.id,
                    empleadoId: empleadoId
                }));
                await CitaEmpleado.bulkCreate(citaEmpleados);
            }

            // Obtener la cita creada con sus relaciones
            const citaConRelaciones = await Cita.findByPk(nuevaCita.id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(201).json({
                success: true,
                data: citaConRelaciones,
                message: 'Cita creada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al crear la cita',
                error: error
            });
        }
    }

    // Actualizar una cita
    public async actualizarCita(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { empleadosIds, ...citaData } = req.body;
            
            const cita = await Cita.findByPk(id);
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            // Actualizar datos de la cita
            await cita.update(citaData);

            // Actualizar relaciones con empleados si se proporcionaron
            if (empleadosIds && Array.isArray(empleadosIds)) {
                // Eliminar relaciones existentes
                await CitaEmpleado.destroy({ where: { citaId: id } });

                // Crear nuevas relaciones
                const citaEmpleados = empleadosIds.map(empleadoId => ({
                    citaId: id,
                    empleadoId: empleadoId
                }));
                await CitaEmpleado.bulkCreate(citaEmpleados);
            }

            // Obtener la cita actualizada con sus relaciones
            const citaActualizada = await Cita.findByPk(id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: citaActualizada,
                message: 'Cita actualizada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar la cita',
                error: error
            });
        }
    }

    // Eliminar una cita
    public async eliminarCita(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const cita = await Cita.findByPk(id);
            
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            // Eliminar las relaciones con empleados
            await CitaEmpleado.destroy({ where: { citaId: id } });
            
            // Eliminar la cita
            await cita.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Cita eliminada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar la cita',
                error: error
            });
        }
    }

    // Obtener citas por cliente
    public async obtenerCitasPorCliente(req: Request, res: Response): Promise<void> {
        try {
            const { clienteId } = req.params;
            const citas = await Cita.findAll({
                where: { clienteId },
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: citas,
                message: 'Citas del cliente obtenidas exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener las citas del cliente',
                error: error
            });
        }
    }
}

export const citaController = new CitaController();import { Request, Response } from 'express';
import { Cliente } from '../models/cliente.model';
import { Op, ValidationError, WhereOptions } from 'sequelize';

// GET all clientes
export const getAllClientes = async (_req: Request, res: Response): Promise<void> => {
  try {
    const clientes = await Cliente.findAll({
      include: ['tipoIdentificacion']
    });
    res.json(clientes);
  } catch (error) {
    console.error('Error al obtener clientes:', error);
    res.status(500).json({ message: 'Error al obtener clientes', error });
  }
};

// GET cliente by ID
export const getClienteById = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id, {
      include: ['tipoIdentificacion']
    });
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }
    res.json(cliente);
  } catch (error) {
    console.error('Error al obtener cliente:', error);
    res.status(500).json({ message: 'Error al obtener cliente', error });
  }
};

// POST create new cliente
export const createCliente = async (req: Request, res: Response): Promise<void> => {
  try {
    // Validar campos requeridos según el tipo de persona
    const { tipoPersona } = req.body;
    if (tipoPersona === 'Moral') {
      if (!req.body.razonSocial || !req.body.rfc || !req.body.fechaConstitucion || !req.body.regimenFiscal) {
        res.status(400).json({
          message: 'Para personas morales, razón social, RFC, fecha de constitución y régimen fiscal son obligatorios'
        });
        return;
      }
    } else if (tipoPersona === 'Física') {
      if (!req.body.curp) {
        res.status(400).json({
          message: 'Para personas físicas, el CURP es obligatorio'
        });
        return;
      }
    } else {
      res.status(400).json({
        message: 'El tipo de persona debe ser "Física" o "Moral"'
      });
      return;
    }

    // Verificar si ya existe un cliente con el mismo CURP, RFC o correo
    const existingCliente = await Cliente.findOne({
      where: {
        [Op.or]: [
          ...(req.body.curp ? [{ curp: req.body.curp }] : []),
          ...(req.body.rfc ? [{ rfc: req.body.rfc }] : []),
          { correo: req.body.correo },
          { numIdentificacion: req.body.numIdentificacion }
        ]
      } as WhereOptions
    });

    if (existingCliente) {
      res.status(400).json({
        message: 'Ya existe un cliente con el mismo CURP, RFC, correo o número de identificación'
      });
      return;
    }

    // Validar formato de RFC si es proporcionado
    if (req.body.rfc && !/^[A-Z&Ñ]{3,4}[0-9]{6}[A-Z0-9]{3}$/.test(req.body.rfc)) {
      res.status(400).json({
        message: 'El formato del RFC no es válido'
      });
      return;
    }

    // Validar formato de CURP si es proporcionado
    if (req.body.curp && !/^[A-Z]{4}[0-9]{6}[HM][A-Z]{5}[0-9A-Z][0-9]$/.test(req.body.curp)) {
      res.status(400).json({
        message: 'El formato del CURP no es válido'
      });
      return;
    }

    const cliente = await Cliente.create(req.body);
    const clienteConRelaciones = await Cliente.findByPk(cliente.id, {
      include: ['tipoIdentificacion']
    });
    
    res.status(201).json(clienteConRelaciones);
  } catch (error) {
    console.error('Error al crear cliente:', error);
    if (error instanceof ValidationError) {
      res.status(400).json({ 
        message: 'Error de validación', 
        errors: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      });
    } else {
      res.status(400).json({ message: 'Error al crear cliente', error });
    }
  }
};

// PUT update cliente
export const updateCliente = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id);
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }

    // Validar campos requeridos según el tipo de persona
    const tipoPersona = req.body.tipoPersona || cliente.tipoPersona;
    if (tipoPersona === 'Moral') {
      const razonSocial = req.body.razonSocial || cliente.razonSocial;
      const rfc = req.body.rfc || cliente.rfc;
      const fechaConstitucion = req.body.fechaConstitucion || cliente.fechaConstitucion;
      const regimenFiscal = req.body.regimenFiscal || cliente.regimenFiscal;

      if (!razonSocial || !rfc || !fechaConstitucion || !regimenFiscal) {
        res.status(400).json({
          message: 'Para personas morales, razón social, RFC, fecha de constitución y régimen fiscal son obligatorios'
        });
        return;
      }
    } else if (tipoPersona === 'Física') {
      const curp = req.body.curp || cliente.curp;
      if (!curp) {
        res.status(400).json({
          message: 'Para personas físicas, el CURP es obligatorio'
        });
        return;
      }
    }

    // Verificar si ya existe otro cliente con el mismo CURP, RFC o correo
    if (req.body.curp || req.body.rfc || req.body.correo || req.body.numIdentificacion) {
      const whereConditions: any[] = [];
      if (req.body.curp) whereConditions.push({ curp: req.body.curp });
      if (req.body.rfc) whereConditions.push({ rfc: req.body.rfc });
      if (req.body.correo) whereConditions.push({ correo: req.body.correo });
      if (req.body.numIdentificacion) whereConditions.push({ numIdentificacion: req.body.numIdentificacion });

      const existingCliente = await Cliente.findOne({
        where: {
          id: { [Op.ne]: req.params.id },
          [Op.or]: whereConditions
        } as WhereOptions
      });

      if (existingCliente) {
        res.status(400).json({
          message: 'Ya existe otro cliente con el mismo CURP, RFC, correo o número de identificación'
        });
        return;
      }
    }

    // Validar formato de RFC si es proporcionado
    if (req.body.rfc && !/^[A-Z&Ñ]{3,4}[0-9]{6}[A-Z0-9]{3}$/.test(req.body.rfc)) {
      res.status(400).json({
        message: 'El formato del RFC no es válido'
      });
      return;
    }

    // Validar formato de CURP si es proporcionado
    if (req.body.curp && !/^[A-Z]{4}[0-9]{6}[HM][A-Z]{5}[0-9A-Z][0-9]$/.test(req.body.curp)) {
      res.status(400).json({
        message: 'El formato del CURP no es válido'
      });
      return;
    }

    await cliente.update(req.body);
    const clienteActualizado = await Cliente.findByPk(req.params.id, {
      include: ['tipoIdentificacion']
    });
    
    res.json(clienteActualizado);
  } catch (error) {
    console.error('Error al actualizar cliente:', error);
    if (error instanceof ValidationError) {
      res.status(400).json({ 
        message: 'Error de validación', 
        errors: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      });
    } else {
      res.status(400).json({ message: 'Error al actualizar cliente', error });
    }
  }
};

// DELETE cliente
export const deleteCliente = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id);
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }
    await cliente.destroy();
    res.status(204).send();
  } catch (error) {
    console.error('Error al eliminar cliente:', error);
    res.status(500).json({ message: 'Error al eliminar cliente', error });
  }
};

// GET clientes by search term
export const searchClientes = async (req: Request<{}, {}, {}, { term: string }>, res: Response): Promise<void> => {
  try {
    const { term } = req.query;
    const clientes = await Cliente.findAll({
      where: {
        [Op.or]: [
          { nombre: { [Op.iLike]: `%${term}%` } },
          { curp: { [Op.iLike]: `%${term}%` } },
          { rfc: { [Op.iLike]: `%${term}%` } },
          { numIdentificacion: { [Op.iLike]: `%${term}%` } },
          { correo: { [Op.iLike]: `%${term}%` } },
          { razonSocial: { [Op.iLike]: `%${term}%` } }
        ]
      },
      include: ['tipoIdentificacion']
    });
    res.json(clientes);
  } catch (error) {
    console.error('Error al buscar clientes:', error);
    res.status(500).json({ message: 'Error al buscar clientes', error });
  }
};import { Request, Response } from 'express';
import { Credito } from '../models/credito.model';

export class CreditoController {
    // Obtener todos los créditos
    public async obtenerCreditos(req: Request, res: Response): Promise<void> {
        try {
            const creditos = await Credito.findAll({
                include: ['cliente', 'vehiculo']
            });
            res.status(200).json({
                success: true,
                data: creditos,
                message: 'Créditos obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los créditos',
                error: error
            });
        }
    }

    // Obtener un crédito por ID
    public async obtenerCreditoPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id, {
                include: ['cliente', 'vehiculo']
            });
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Crédito no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: credito,
                message: 'Crédito obtenido exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener el crédito',
                error: error
            });
        }
    }

    // Crear un nuevo crédito
    public async crearCredito(req: Request, res: Response): Promise<void> {
        try {
            const nuevoCredito = await Credito.create(req.body);
            
            // Obtener el crédito creado con sus relaciones
            const creditoConRelaciones = await Credito.findByPk(nuevoCredito.id, {
                include: ['cliente', 'vehiculo']
            });

            res.status(201).json({
                success: true,
                data: creditoConRelaciones,
                message: 'Crédito creado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al crear el crédito',
                error: error
            });
        }
    }

    // Actualizar un crédito
    public async actualizarCredito(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id);
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Crédito no encontrado'
                });
                return;
            }

            await credito.update(req.body);
            
            // Obtener el crédito actualizado con sus relaciones
            const creditoActualizado = await Credito.findByPk(id, {
                include: ['cliente', 'vehiculo']
            });

            res.status(200).json({
                success: true,
                data: creditoActualizado,
                message: 'Crédito actualizado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el crédito',
                error: error
            });
        }
    }

    // Eliminar un crédito
    public async eliminarCredito(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id);
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Crédito no encontrado'
                });
                return;
            }

            await credito.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Crédito eliminado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el crédito',
                error: error
            });
        }
    }

    // Obtener créditos por cliente
    public async obtenerCreditosPorCliente(req: Request, res: Response): Promise<void> {
        try {
            const { clienteId } = req.params;
            const creditos = await Credito.findAll({
                where: { clienteId },
                include: ['cliente', 'vehiculo']
            });

            res.status(200).json({
                success: true,
                data: creditos,
                message: 'Créditos del cliente obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los créditos del cliente',
                error: error
            });
        }
    }
}

export const creditoController = new CreditoController();import { Request, Response } from 'express';
import { Documento } from '../models/documento.model';
import { moveFileToFinal } from '../middlewares/upload.middleware';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

export class DocumentoController {
    // Función auxiliar para generar el hash de un archivo
    private generarHashArchivo = async (filePath: string): Promise<string> => {
        return new Promise((resolve, reject) => {
            const hash = crypto.createHash('sha256');
            const stream = fs.createReadStream(filePath);
            
            stream.on('error', err => reject(err));
            stream.on('data', chunk => hash.update(chunk));
            stream.on('end', () => resolve(hash.digest('hex')));
        });
    }

    // Función auxiliar para determinar la entidad origen
    private determinarEntidadOrigen = (body: any): 'cliente' | 'empleado' | 'vehiculo' | 'transaccion' | 'general' => {
        if (body.id_empleado) return 'empleado';
        if (body.id_cliente) return 'cliente';
        if (body.id_vehiculo) return 'vehiculo';
        if (body.id_transaccion) return 'transaccion';
        return 'general';
    }

    // Obtener todos los documentos
    public obtenerDocumentos = async (req: Request, res: Response): Promise<void> => {
        try {
            const documentos = await Documento.findAll();
            res.status(200).json({
                success: true,
                data: documentos,
                message: 'Documentos obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los documentos',
                error: error
            });
        }
    }

    // Obtener documentos por empleado
    public obtenerDocumentosPorEmpleado = async (req: Request, res: Response): Promise<void> => {
        try {
            const { idEmpleado } = req.params;
            const documentos = await Documento.getDocumentosPorTipoYEntidad('empleado', {
                idEmpleado: parseInt(idEmpleado)
            });
            
            // Verificar si hay documentos pendientes
            const documentosPendientes = documentos.some(doc => doc.estado === 'pendiente');
            
            res.status(200).json({
                success: true,
                data: {
                    documentosPendientes,
                    documentos
                },
                message: 'Documentos del empleado obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los documentos del empleado',
                error: error
            });
        }
    }

    // Obtener un documento por ID
    public obtenerDocumentoPorId = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento obtenido exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener el documento',
                error: error
            });
        }
    }

    // Crear un nuevo documento
    public crearDocumento = async (req: Request, res: Response): Promise<void> => {
        try {
            const file = req.file;
            if (!file) {
                res.status(400).json({
                    success: false,
                    message: 'No se ha proporcionado ningún archivo'
                });
                return;
            }

            // Mover el archivo al directorio de documentos
            const documentosDir = path.join(process.cwd(), 'uploads', 'documentos');
            if (!fs.existsSync(documentosDir)) {
                fs.mkdirSync(documentosDir, { recursive: true });
            }

            const finalPath = path.join(documentosDir, file.filename);
            fs.renameSync(file.path, finalPath);
            
            // Generar hash del archivo
            const hashArchivo = await this.generarHashArchivo(finalPath);
            
            // Determinar la entidad origen
            const entidadOrigen = this.determinarEntidadOrigen(req.body);
            
            // Determinar el tipo de documento específico según la entidad
            let tipoDocumentoEspecifico = null;
            if (entidadOrigen === 'empleado' && req.body.tipo_documento_empleado) {
                tipoDocumentoEspecifico = {
                    tipo_documento_empleado: req.body.tipo_documento_empleado
                };
            } else if (entidadOrigen === 'vehiculo' && req.body.tipo_documento_vehiculo) {
                tipoDocumentoEspecifico = {
                    tipo_documento_vehiculo: req.body.tipo_documento_vehiculo
                };
            } else if (entidadOrigen === 'transaccion' && req.body.tipo_documento_transaccion) {
                tipoDocumentoEspecifico = {
                    tipo_documento_transaccion: req.body.tipo_documento_transaccion
                };
            }
            
            const fileUrl = `/uploads/documentos/${file.filename}`;
            
            const nuevoDocumento = await Documento.create({
                ...req.body,
                ...tipoDocumentoEspecifico,
                url: fileUrl,
                estado: 'pendiente',
                fecha_subida: new Date(),
                nombre_archivo_original: file.originalname,
                mime_type: file.mimetype,
                tamanio_archivo: file.size,
                hash_archivo: hashArchivo,
                entidad_origen: entidadOrigen
            });
    
            res.status(201).json({
                success: true,
                data: nuevoDocumento,
                message: 'Documento creado exitosamente'
            });
        } catch (error) {
            // Si hay un error, intentar eliminar el archivo si existe
            if (req.file) {
                const filePath = path.join(process.cwd(), 'uploads', 'documentos', req.file.filename);
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                }
            }

            console.error('Error al crear documento:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el documento',
                error: error
            });
        }
    }

    // Actualizar un documento
    public actualizarDocumento = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            // Si hay un nuevo archivo
            if (req.file) {
                // Eliminar el archivo anterior
                const oldFilePath = path.join(process.cwd(), documento.url);
                if (fs.existsSync(oldFilePath)) {
                    fs.unlinkSync(oldFilePath);
                }

                // Mover el nuevo archivo al directorio de documentos
                const documentosDir = path.join(process.cwd(), 'uploads', 'documentos');
                if (!fs.existsSync(documentosDir)) {
                    fs.mkdirSync(documentosDir, { recursive: true });
                }

                const finalPath = path.join(documentosDir, req.file.filename);
                fs.renameSync(req.file.path, finalPath);
                
                // Generar hash del nuevo archivo
                const hashArchivo = await this.generarHashArchivo(finalPath);
                
                req.body.url = `/uploads/documentos/${req.file.filename}`;
                req.body.nombre_archivo_original = req.file.originalname;
                req.body.mime_type = req.file.mimetype;
                req.body.tamanio_archivo = req.file.size;
                req.body.hash_archivo = hashArchivo;
            }

            await documento.update(req.body);
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento actualizado exitosamente'
            });
        } catch (error) {
            // Si hay un error y se subió un nuevo archivo, intentar eliminarlo
            if (req.file) {
                const filePath = path.join(process.cwd(), 'uploads', 'documentos', req.file.filename);
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                }
            }

            res.status(500).json({
                success: false,
                message: 'Error al actualizar el documento',
                error: error
            });
        }
    }

    // Aprobar un documento
    public aprobarDocumento = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            if (documento.estado !== 'pendiente') {
                res.status(400).json({
                    success: false,
                    message: 'El documento no está en estado pendiente'
                });
                return;
            }

            await documento.cambiarEstado('aprobado', req.body.idUsuario, req.body.comentario);
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento aprobado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al aprobar el documento',
                error: error
            });
        }
    }

    // Rechazar un documento
    public rechazarDocumento = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            if (documento.estado !== 'pendiente') {
                res.status(400).json({
                    success: false,
                    message: 'El documento no está en estado pendiente'
                });
                return;
            }

            await documento.cambiarEstado('rechazado', req.body.idUsuario, req.body.comentario);
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento rechazado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al rechazar el documento',
                error: error
            });
        }
    }

    // Eliminar un documento
    public eliminarDocumento = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            // Eliminar el archivo físico
            const filePath = path.join(process.cwd(), documento.url);
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }

            await documento.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Documento eliminado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el documento',
                error: error
            });
        }
    }

    // Verificar integridad del documento
    public verificarIntegridad = async (req: Request, res: Response): Promise<void> => {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            const filePath = path.join(process.cwd(), documento.url);
            if (!fs.existsSync(filePath)) {
                res.status(404).json({
                    success: false,
                    message: 'Archivo físico no encontrado'
                });
                return;
            }

            const hashActual = await this.generarHashArchivo(filePath);
            const integridadVerificada = hashActual === documento.hashArchivo;

            res.status(200).json({
                success: true,
                data: {
                    integridadVerificada,
                    hashOriginal: documento.hashArchivo,
                    hashActual
                },
                message: integridadVerificada 
                    ? 'La integridad del documento ha sido verificada'
                    : 'El documento ha sido modificado'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al verificar la integridad del documento',
                error: error
            });
        }
    }
}

export const documentoController = new DocumentoController();import { Request, Response } from 'express';
import { Usuario } from '../models/usuario.model';
import { Empleado } from '../models/empleado.model';
import { TipoIdentificacion } from '../models/catalogs/tipo-identificacion.model';
import { Op } from 'sequelize';
import bcrypt from 'bcrypt';

const MIN_DOMICILIO_LENGTH = 10;
const MAX_DOMICILIO_LENGTH = 200;
const MIN_AGE = 18;

export class EmpleadoController {
    private validateDates(fechaNacimiento: Date, fechaContratacion: Date): string | null {
        const today = new Date();
        const age = Math.floor((today.getTime() - fechaNacimiento.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
        
        if (age < MIN_AGE) {
            return `El empleado debe ser mayor de ${MIN_AGE} años`;
        }

        if (fechaContratacion > today) {
            return 'La fecha de contratación no puede ser futura';
        }

        return null;
    }

    private validateDomicilio(domicilio: string): string | null {
        if (domicilio.length < MIN_DOMICILIO_LENGTH) {
            return `El domicilio debe tener al menos ${MIN_DOMICILIO_LENGTH} caracteres`;
        }
        if (domicilio.length > MAX_DOMICILIO_LENGTH) {
            return `El domicilio no puede exceder ${MAX_DOMICILIO_LENGTH} caracteres`;
        }
        return null;
    }

    private async validateUniqueEmail(correo: string): Promise<string | null> {
        const existingUser = await Usuario.findOne({ where: { correo } });
        if (existingUser) {
            return 'El correo electrónico ya está registrado';
        }
        return null;
    }

    // Obtener todos los empleados con sus datos de usuario
    public async obtenerEmpleados(req: Request, res: Response): Promise<void> {
        try {
            const empleados = await Empleado.findAll({
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });
            
            res.status(200).json({
                success: true,
                data: empleados,
                message: 'Empleados obtenidos exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener empleados:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los empleados',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un empleado por ID
    public async obtenerEmpleadoPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });
            
            if (!empleado) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: empleado,
                message: 'Empleado obtenido exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Crear un nuevo empleado junto con su usuario
    public async crearEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { usuario: usuarioData, empleado: empleadoData } = req.body;

            // Validar fechas
            const dateError = this.validateDates(
                new Date(empleadoData.fechaNacimiento),
                new Date(empleadoData.fechaContratacion)
            );
            if (dateError) {
                res.status(400).json({
                    success: false,
                    message: dateError
                });
                return;
            }

            // Validar domicilio
            const domicilioError = this.validateDomicilio(empleadoData.domicilio);
            if (domicilioError) {
                res.status(400).json({
                    success: false,
                    message: domicilioError
                });
                return;
            }

            // Validar correo único
            const emailError = await this.validateUniqueEmail(usuarioData.correo);
            if (emailError) {
                res.status(400).json({
                    success: false,
                    message: emailError
                });
                return;
            }
            
            // Encriptar contraseña
            const salt = await bcrypt.genSalt(10);
            const hashedPassword = await bcrypt.hash(usuarioData.password, salt);

            // Crear usuario
            const nuevoUsuario = await Usuario.create({
                ...usuarioData,
                password: hashedPassword,
                is_active: true,
                is_locked: false
            });

            // Crear empleado asociado al usuario
            const nuevoEmpleado = await Empleado.create({
                ...empleadoData,
                idUsuario: nuevoUsuario.id
            });

            // Obtener el empleado con sus relaciones
            const empleadoCompleto = await Empleado.findOne({
                where: { id: nuevoEmpleado.id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });

            res.status(201).json({
                success: true,
                data: empleadoCompleto,
                message: 'Empleado creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear empleado:', error);
            
            // Si es un error de validación de Sequelize
            if (error instanceof Error && error.name === 'SequelizeValidationError') {
                res.status(400).json({
                    success: false,
                    message: 'Error de validación',
                    errors: (error as any).errors.map((e: any) => ({
                        field: e.path,
                        message: e.message
                    }))
                });
                return;
            }

            // Si es un error de unicidad
            if (error instanceof Error && error.name === 'SequelizeUniqueConstraintError') {
                res.status(400).json({
                    success: false,
                    message: 'Error de unicidad',
                    errors: (error as any).errors.map((e: any) => ({
                        field: e.path,
                        message: e.message
                    }))
                });
                return;
            }

            res.status(500).json({
                success: false,
                message: 'Error al crear el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un empleado
    public async actualizarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { usuario: usuarioData, empleado: empleadoData } = req.body;

            const empleadoExistente = await Empleado.findOne({
                where: { id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario'
                    }
                ]
            });
            
            if (!empleadoExistente) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            // Validar fechas si se están actualizando
            if (empleadoData.fechaNacimiento || empleadoData.fechaContratacion) {
                const dateError = this.validateDates(
                    new Date(empleadoData.fechaNacimiento || empleadoExistente.fechaNacimiento),
                    new Date(empleadoData.fechaContratacion || empleadoExistente.fechaContratacion)
                );
                if (dateError) {
                    res.status(400).json({
                        success: false,
                        message: dateError
                    });
                    return;
                }
            }

            // Validar domicilio si se está actualizando
            if (empleadoData.domicilio) {
                const domicilioError = this.validateDomicilio(empleadoData.domicilio);
                if (domicilioError) {
                    res.status(400).json({
                        success: false,
                        message: domicilioError
                    });
                    return;
                }
            }

            // Validar correo único si se está actualizando
            if (usuarioData?.correo && usuarioData.correo !== empleadoExistente.usuario?.correo) {
                const emailError = await this.validateUniqueEmail(usuarioData.correo);
                if (emailError) {
                    res.status(400).json({
                        success: false,
                        message: emailError
                    });
                    return;
                }
            }

            // Actualizar datos del usuario si se proporcionan
            if (usuarioData && empleadoExistente.usuario) {
                const datosUsuario = { ...usuarioData };
                if (usuarioData.password) {
                    const salt = await bcrypt.genSalt(10);
                    datosUsuario.password = await bcrypt.hash(usuarioData.password, salt);
                }
                await Usuario.update(datosUsuario, {
                    where: { id: empleadoExistente.usuario.id }
                });
            }

            // Actualizar datos del empleado
            await empleadoExistente.update(empleadoData);

            // Obtener el empleado actualizado con sus relaciones
            const empleadoActualizado = await Empleado.findOne({
                where: { id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: empleadoActualizado,
                message: 'Empleado actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar empleado:', error);
            
            // Si es un error de validación de Sequelize
            if (error instanceof Error && error.name === 'SequelizeValidationError') {
                res.status(400).json({
                    success: false,
                    message: 'Error de validación',
                    errors: (error as any).errors.map((e: any) => ({
                        field: e.path,
                        message: e.message
                    }))
                });
                return;
            }

            // Si es un error de unicidad
            if (error instanceof Error && error.name === 'SequelizeUniqueConstraintError') {
                res.status(400).json({
                    success: false,
                    message: 'Error de unicidad',
                    errors: (error as any).errors.map((e: any) => ({
                        field: e.path,
                        message: e.message
                    }))
                });
                return;
            }

            res.status(500).json({
                success: false,
                message: 'Error al actualizar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Desactivar un empleado (soft delete del usuario asociado)
    public async desactivarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id },
                include: [{ model: Usuario, as: 'usuario' }]
            });
            
            if (!empleado || !empleado.usuario) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            await Usuario.update(
                { is_active: false },
                { where: { id: empleado.usuario.id } }
            );
            
            res.status(200).json({
                success: true,
                message: 'Empleado desactivado exitosamente'
            });
        } catch (error) {
            console.error('Error al desactivar empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Reactivar un empleado
    public async reactivarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id },
                include: [{ model: Usuario, as: 'usuario' }]
            });
            
            if (!empleado || !empleado.usuario) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            await Usuario.update(
                { is_active: true },
                { where: { id: empleado.usuario.id } }
            );
            
            res.status(200).json({
                success: true,
                message: 'Empleado reactivado exitosamente'
            });
        } catch (error) {
            console.error('Error al reactivar empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al reactivar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}

export const empleadoController = new EmpleadoController();import { Request, Response } from 'express';
import ScannerService from '../services/scanner.service';
import { ScanOptions } from '../config/scanner.config';
import * as fs from 'fs';
import * as path from 'path';

class ScannerController {
  private static instance: ScannerController;
  private scannerService: ScannerService;
  private configPath: string;

  private constructor() {
    this.scannerService = ScannerService.getInstance();
    this.configPath = path.join(process.cwd(), 'backend/src/config/scanner.config.ts');
  }

  public static getInstance(): ScannerController {
    if (!ScannerController.instance) {
      ScannerController.instance = new ScannerController();
    }
    return ScannerController.instance;
  }

  public async getStatus(_req: Request, res: Response): Promise<void> {
    try {
      const status = await this.scannerService.getScannerStatus();
      res.json({ status });
    } catch (error) {
      console.error('Error al obtener estado del escáner:', error);
      res.status(500).json({ 
        error: 'Error al obtener estado del escáner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async startScan(req: Request, res: Response): Promise<void> {
    try {
      const options: ScanOptions = {
        resolution: req.body.resolution || 300,
        colorMode: req.body.colorMode || 'Color',
        paperSize: req.body.paperSize || 'A4',
        outputFormat: req.body.outputFormat || 'PDF',
        duplex: req.body.duplex || false,
        brightness: req.body.brightness || 0,
        contrast: req.body.contrast || 0,
        documentId: req.body.documentId,
        clienteId: req.body.clienteId,
        tipoDocumento: req.body.tipoDocumento
      };

      const success = await this.scannerService.startScan(options);
      
      if (success) {
        res.json({ message: 'Escaneo iniciado correctamente' });
      } else {
        res.status(500).json({ error: 'Error al iniciar el escaneo' });
      }
    } catch (error) {
      console.error('Error al iniciar escaneo:', error);
      res.status(500).json({ 
        error: 'Error al iniciar escaneo',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async configure(req: Request, res: Response): Promise<void> {
    try {
      const currentConfig = {
        scannerIp: process.env.SCANNER_IP || '192.168.100.200',
        snmpCommunity: process.env.SNMP_COMMUNITY || 'public',
        uploadPath: process.env.SCANNER_UPLOAD_PATH || '/home/ubuntu/cliqueanet/backend/uploads/scanner'
      };

      if (req.method === 'GET') {
        res.json(currentConfig);
        return;
      }

      const newConfig = {
        scannerIp: req.body.scannerIp || currentConfig.scannerIp,
        snmpCommunity: req.body.snmpCommunity || currentConfig.snmpCommunity,
        uploadPath: req.body.uploadPath || currentConfig.uploadPath
      };

      // Actualizar variables de entorno
      process.env.SCANNER_IP = newConfig.scannerIp;
      process.env.SNMP_COMMUNITY = newConfig.snmpCommunity;
      process.env.SCANNER_UPLOAD_PATH = newConfig.uploadPath;

      // Asegurarse de que el directorio de uploads existe
      if (!fs.existsSync(newConfig.uploadPath)) {
        fs.mkdirSync(newConfig.uploadPath, { recursive: true });
      }

      // Reinicializar el servicio del escáner con la nueva configuración
      await this.scannerService.reinitialize(newConfig);

      res.json({
        message: 'Configuración actualizada correctamente',
        config: newConfig
      });
    } catch (error) {
      console.error('Error al configurar escáner:', error);
      res.status(500).json({ 
        error: 'Error al configurar escáner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async testConnection(_req: Request, res: Response): Promise<void> {
    try {
      const status = await this.scannerService.getScannerStatus();
      if (status === 'READY' || status === 'BUSY') {
        res.json({ 
          connected: true,
          status,
          message: 'Conexión exitosa con el escáner'
        });
      } else {
        res.status(503).json({ 
          connected: false,
          status,
          message: 'El escáner no está disponible'
        });
      }
    } catch (error) {
      console.error('Error al probar conexión:', error);
      res.status(500).json({ 
        connected: false,
        error: 'Error al probar conexión con el escáner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }
}

export default ScannerController;import { Request, Response } from 'express';
import { Transaccion } from '../models/transaccion.model';

// GET all transacciones
export const getAllTransacciones = async (_req: Request, res: Response): Promise<void> => {
  try {
    const transacciones = await Transaccion.findAll({
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    res.json(transacciones);
  } catch (error) {
    console.error('Error al obtener transacciones:', error);
    res.status(500).json({ message: 'Error al obtener transacciones', error });
  }
};

// GET transaccion by ID
export const getTransaccionById = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    if (!transaccion) {
      res.status(404).json({ message: 'Transacción no encontrada' });
      return;
    }
    res.json(transaccion);
  } catch (error) {
    console.error('Error al obtener transacción:', error);
    res.status(500).json({ message: 'Error al obtener transacción', error });
  }
};

// POST create new transaccion
export const createTransaccion = async (req: Request, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.create({
      ...req.body,
      fecha: new Date()
    });
    
    const transaccionConRelaciones = await Transaccion.findByPk(transaccion.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    
    res.status(201).json(transaccionConRelaciones);
  } catch (error) {
    console.error('Error al crear transacción:', error);
    res.status(400).json({ message: 'Error al crear transacción', error });
  }
};

// PUT update transaccion
export const updateTransaccion = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id);
    if (!transaccion) {
      res.status(404).json({ message: 'Transacción no encontrada' });
      return;
    }

    await transaccion.update(req.body);
    
    const transaccionActualizada = await Transaccion.findByPk(req.params.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    
    res.json(transaccionActualizada);
  } catch (error) {
    console.error('Error al actualizar transacción:', error);
    res.status(400).json({ message: 'Error al actualizar transacción', error });
  }
};

// DELETE transaccion
export const deleteTransaccion = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id);
    if (!transaccion) {
      res.status(404).json({ message: 'Transacción no encontrada' });
      return;
    }
    await transaccion.destroy();
    res.status(204).send();
  } catch (error) {
    console.error('Error al eliminar transacción:', error);
    res.status(500).json({ message: 'Error al eliminar transacción', error });
  }
};import { Request, Response } from 'express';
import Usuario from '../models/usuario.model';
import { CreateUsuario, UpdateUsuario, LoginCredentials, RolUsuario } from '../types';
import { hashPassword } from '../middlewares/auth.middleware';

export class UsuarioController {
  login = async (req: Request, res: Response): Promise<void> => {
    try {
      console.log('🚀 Login request received:', req.body);
      const credentials: LoginCredentials = {
        ...req.body,
        ip_address: req.realIP // Usar la IP real del middleware
      };
      
      // Validar que se proporcione al menos un método de identificación
      if (!credentials.employeeId && !credentials.correo) {
        console.log('❌ No se proporcionó método de identificación');
        res.status(400).json({
          success: false,
          message: 'Debe proporcionar un número de empleado o correo electrónico'
        });
        return;
      }

      // Validar contraseña
      if (!credentials.password) {
        console.log('❌ No se proporcionó contraseña');
        res.status(400).json({
          success: false,
          message: 'Debe proporcionar una contraseña'
        });
        return;
      }

      console.log('✅ Validaciones pasadas, intentando login');
      const result = await Usuario.login(credentials);

      if (!result) {
        console.log('❌ Login fallido: credenciales inválidas');
        res.status(401).json({
          success: false,
          message: 'Credenciales inválidas'
        });
        return;
      }

      console.log('✅ Login exitoso');
      res.status(200).json({
        success: true,
        data: result,
        message: 'Login exitoso'
      });
    } catch (error) {
      console.error('❌ Error en el proceso de login:', error);
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error en el proceso de login'
      });
    }
  };

  crearUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const usuarioData: CreateUsuario = req.body;

      // Validar contraseña
      if (!/^(?=.*[A-Z])(?=.*\d).{8,}$/.test(usuarioData.password)) {
        res.status(400).json({
          success: false,
          message: 'La contraseña debe tener al menos 8 caracteres, una mayúscula y un número'
        });
        return;
      }

      // Hash de la contraseña
      usuarioData.password = await hashPassword(usuarioData.password);
      
      const nuevoUsuario = await Usuario.create(usuarioData);
      
      // Excluir la contraseña de la respuesta
      const { password, ...usuarioSinPassword } = nuevoUsuario.toJSON();
      
      res.status(201).json({
        success: true,
        data: usuarioSinPassword,
        message: 'Usuario creado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al crear usuario'
      });
    }
  };

  obtenerUsuarioPorId = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const usuario = await Usuario.findByPk(id, {
        attributes: { exclude: ['password'] }
      });
      
      if (!usuario) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: usuario
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al obtener usuario'
      });
    }
  };

  obtenerTodosUsuarios = async (_req: Request, res: Response): Promise<void> => {
    try {
      const usuarios = await Usuario.findAll({
        attributes: { exclude: ['password'] }
      });
      res.status(200).json({
        success: true,
        data: usuarios
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al obtener usuarios'
      });
    }
  };

  actualizarUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const usuarioData: UpdateUsuario = req.body;

      // Si se actualiza la contraseña, validar y hashear
      if (usuarioData.password) {
        if (!/^(?=.*[A-Z])(?=.*\d).{8,}$/.test(usuarioData.password)) {
          res.status(400).json({
            success: false,
            message: 'La contraseña debe tener al menos 8 caracteres, una mayúscula y un número'
          });
          return;
        }
        usuarioData.password = await hashPassword(usuarioData.password);
      }

      const [numRows, [usuarioActualizado]] = await Usuario.update(usuarioData, {
        where: { id_empleado: id },
        returning: true
      });

      if (numRows === 0) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }

      // Excluir la contraseña de la respuesta
      const { password, ...usuarioSinPassword } = usuarioActualizado.toJSON();
      
      res.status(200).json({
        success: true,
        data: usuarioSinPassword,
        message: 'Usuario actualizado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al actualizar usuario'
      });
    }
  };

  eliminarUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const numRows = await Usuario.destroy({
        where: { id_empleado: id }
      });
      
      if (numRows === 0) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }
      
      res.status(200).json({
        success: true,
        message: 'Usuario eliminado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al eliminar usuario'
      });
    }
  };

  buscarUsuariosPorRol = async (req: Request, res: Response): Promise<void> => {
    try {
      const rolId = parseInt(req.params.rol);
      if (isNaN(rolId) || !Object.values(RolUsuario).includes(rolId)) {
        res.status(400).json({
          success: false,
          message: 'Rol inválido'
        });
        return;
      }

      const usuarios = await Usuario.findAll({
        where: { id_rol: rolId },
        attributes: { exclude: ['password'] }
      });
      
      res.status(200).json({
        success: true,
        data: usuarios
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al buscar usuarios por rol'
      });
    }
  };

  buscarUsuarioPorCorreo = async (req: Request, res: Response): Promise<void> => {
    try {
      const { correo } = req.params;
      const usuario = await Usuario.findOne({
        where: { correo },
        attributes: { exclude: ['password'] }
      });
      
      if (!usuario) {
        res.status(404).json({
          success: false,
          message: `Usuario con correo ${correo} no encontrado`
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: usuario
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al buscar usuario por correo'
      });
    }
  };
}import { Request, Response } from 'express';
import { Vehiculo } from '../models/vehiculo.model';
import { Op } from 'sequelize';

export class VehiculoController {
    
    // Crear un nuevo vehículo
    public async create(req: Request, res: Response): Promise<void> {
        try {
            const {
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            } = req.body;

            // Validar campos requeridos
            if (!marca || !modelo || !anio || !precio || !numSerie || !color || !numMotor) {
                res.status(400).json({
                    success: false,
                    message: 'Todos los campos obligatorios deben ser proporcionados'
                });
                return;
            }

            const vehiculo = await Vehiculo.create({
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            });

            res.status(201).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear vehículo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener todos los vehículos
    public async getAll(req: Request, res: Response): Promise<void> {
        try {
            const vehiculos = await Vehiculo.findAll();
            res.status(200).json({
                success: true,
                data: vehiculos,
                message: 'Vehículos recuperados exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener vehículos:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los vehículos',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un vehículo por ID
    public async getById(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener vehículo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener vehículo por número de serie
    public async getByNumSerie(req: Request, res: Response): Promise<void> {
        try {
            const { numSerie } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { numSerie }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener vehículo por número de serie:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener vehículo por placas
    public async getByPlacas(req: Request, res: Response): Promise<void> {
        try {
            const { placas } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { placas }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener vehículo por placas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener vehículo por número de motor
    public async getByNumMotor(req: Request, res: Response): Promise<void> {
        try {
            const { numMotor } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { numMotor }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener vehículo por número de motor:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un vehículo
    public async update(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            const {
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            } = req.body;

            // Validar campos requeridos
            if (!marca || !modelo || !anio || !precio || !numSerie || !color || !numMotor) {
                res.status(400).json({
                    success: false,
                    message: 'Todos los campos obligatorios deben ser proporcionados'
                });
                return;
            }

            await vehiculo.update({
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            });

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Vehículo actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar vehículo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Eliminar un vehículo
    public async delete(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Vehículo no encontrado'
                });
                return;
            }

            await vehiculo.destroy();

            res.status(200).json({
                success: true,
                message: 'Vehículo eliminado exitosamente'
            });
        } catch (error) {
            console.error('Error al eliminar vehículo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el vehículo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}