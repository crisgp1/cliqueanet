import { Request, Response } from 'express';
import { Cita } from '../models/cita.model';
import { CitaEmpleado } from '../models/cita-empleado.model';

export class CitaController {
    // Obtener todas las citas
    public async obtenerCitas(req: Request, res: Response): Promise<void> {
        try {
            const citas = await Cita.findAll({
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });
            res.status(200).json({
                success: true,
                data: citas,
                message: 'Citas obtenidas exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener las citas',
                error: error
            });
        }
    }

    // Obtener una cita por ID
    public async obtenerCitaPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const cita = await Cita.findByPk(id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });
            
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: cita,
                message: 'Cita obtenida exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener la cita',
                error: error
            });
        }
    }

    // Crear una nueva cita
    public async crearCita(req: Request, res: Response): Promise<void> {
        try {
            const { empleadosIds, ...citaData } = req.body;
            const nuevaCita = await Cita.create(citaData);

            // Crear las relaciones con empleados si se proporcionaron
            if (empleadosIds && Array.isArray(empleadosIds)) {
                const citaEmpleados = empleadosIds.map(empleadoId => ({
                    citaId: nuevaCita.id,
                    empleadoId: empleadoId
                }));
                await CitaEmpleado.bulkCreate(citaEmpleados);
            }

            // Obtener la cita creada con sus relaciones
            const citaConRelaciones = await Cita.findByPk(nuevaCita.id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(201).json({
                success: true,
                data: citaConRelaciones,
                message: 'Cita creada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al crear la cita',
                error: error
            });
        }
    }

    // Actualizar una cita
    public async actualizarCita(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { empleadosIds, ...citaData } = req.body;
            
            const cita = await Cita.findByPk(id);
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            // Actualizar datos de la cita
            await cita.update(citaData);

            // Actualizar relaciones con empleados si se proporcionaron
            if (empleadosIds && Array.isArray(empleadosIds)) {
                // Eliminar relaciones existentes
                await CitaEmpleado.destroy({ where: { citaId: id } });

                // Crear nuevas relaciones
                const citaEmpleados = empleadosIds.map(empleadoId => ({
                    citaId: id,
                    empleadoId: empleadoId
                }));
                await CitaEmpleado.bulkCreate(citaEmpleados);
            }

            // Obtener la cita actualizada con sus relaciones
            const citaActualizada = await Cita.findByPk(id, {
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: citaActualizada,
                message: 'Cita actualizada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar la cita',
                error: error
            });
        }
    }

    // Eliminar una cita
    public async eliminarCita(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const cita = await Cita.findByPk(id);
            
            if (!cita) {
                res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
                return;
            }

            // Eliminar las relaciones con empleados
            await CitaEmpleado.destroy({ where: { citaId: id } });
            
            // Eliminar la cita
            await cita.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Cita eliminada exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar la cita',
                error: error
            });
        }
    }

    // Obtener citas por cliente
    public async obtenerCitasPorCliente(req: Request, res: Response): Promise<void> {
        try {
            const { clienteId } = req.params;
            const citas = await Cita.findAll({
                where: { clienteId },
                include: [
                    'cliente',
                    {
                        model: CitaEmpleado,
                        as: 'citaEmpleados',
                        include: ['empleado']
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: citas,
                message: 'Citas del cliente obtenidas exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener las citas del cliente',
                error: error
            });
        }
    }
}

export const citaController = new CitaController();import { Request, Response } from 'express';
import { Cliente } from '../models/cliente.model';
import { Op, ValidationError, WhereOptions } from 'sequelize';

// GET all clientes
export const getAllClientes = async (_req: Request, res: Response): Promise<void> => {
  try {
    const clientes = await Cliente.findAll({
      include: ['tipoIdentificacion']
    });
    res.json(clientes);
  } catch (error) {
    console.error('Error al obtener clientes:', error);
    res.status(500).json({ message: 'Error al obtener clientes', error });
  }
};

// GET cliente by ID
export const getClienteById = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id, {
      include: ['tipoIdentificacion']
    });
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }
    res.json(cliente);
  } catch (error) {
    console.error('Error al obtener cliente:', error);
    res.status(500).json({ message: 'Error al obtener cliente', error });
  }
};

// POST create new cliente
export const createCliente = async (req: Request, res: Response): Promise<void> => {
  try {
    // Validar campos requeridos seg√∫n el tipo de persona
    const { tipoPersona } = req.body;
    if (tipoPersona === 'Moral') {
      if (!req.body.razonSocial || !req.body.rfc || !req.body.fechaConstitucion || !req.body.regimenFiscal) {
        res.status(400).json({
          message: 'Para personas morales, raz√≥n social, RFC, fecha de constituci√≥n y r√©gimen fiscal son obligatorios'
        });
        return;
      }
    } else if (tipoPersona === 'F√≠sica') {
      if (!req.body.curp) {
        res.status(400).json({
          message: 'Para personas f√≠sicas, el CURP es obligatorio'
        });
        return;
      }
    } else {
      res.status(400).json({
        message: 'El tipo de persona debe ser "F√≠sica" o "Moral"'
      });
      return;
    }

    // Verificar si ya existe un cliente con el mismo CURP, RFC o correo
    const existingCliente = await Cliente.findOne({
      where: {
        [Op.or]: [
          ...(req.body.curp ? [{ curp: req.body.curp }] : []),
          ...(req.body.rfc ? [{ rfc: req.body.rfc }] : []),
          { correo: req.body.correo },
          { numIdentificacion: req.body.numIdentificacion }
        ]
      } as WhereOptions
    });

    if (existingCliente) {
      res.status(400).json({
        message: 'Ya existe un cliente con el mismo CURP, RFC, correo o n√∫mero de identificaci√≥n'
      });
      return;
    }

    // Validar formato de RFC si es proporcionado
    if (req.body.rfc && !/^[A-Z&√ë]{3,4}[0-9]{6}[A-Z0-9]{3}$/.test(req.body.rfc)) {
      res.status(400).json({
        message: 'El formato del RFC no es v√°lido'
      });
      return;
    }

    // Validar formato de CURP si es proporcionado
    if (req.body.curp && !/^[A-Z]{4}[0-9]{6}[HM][A-Z]{5}[0-9A-Z][0-9]$/.test(req.body.curp)) {
      res.status(400).json({
        message: 'El formato del CURP no es v√°lido'
      });
      return;
    }

    const cliente = await Cliente.create(req.body);
    const clienteConRelaciones = await Cliente.findByPk(cliente.id, {
      include: ['tipoIdentificacion']
    });
    
    res.status(201).json(clienteConRelaciones);
  } catch (error) {
    console.error('Error al crear cliente:', error);
    if (error instanceof ValidationError) {
      res.status(400).json({ 
        message: 'Error de validaci√≥n', 
        errors: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      });
    } else {
      res.status(400).json({ message: 'Error al crear cliente', error });
    }
  }
};

// PUT update cliente
export const updateCliente = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id);
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }

    // Validar campos requeridos seg√∫n el tipo de persona
    const tipoPersona = req.body.tipoPersona || cliente.tipoPersona;
    if (tipoPersona === 'Moral') {
      const razonSocial = req.body.razonSocial || cliente.razonSocial;
      const rfc = req.body.rfc || cliente.rfc;
      const fechaConstitucion = req.body.fechaConstitucion || cliente.fechaConstitucion;
      const regimenFiscal = req.body.regimenFiscal || cliente.regimenFiscal;

      if (!razonSocial || !rfc || !fechaConstitucion || !regimenFiscal) {
        res.status(400).json({
          message: 'Para personas morales, raz√≥n social, RFC, fecha de constituci√≥n y r√©gimen fiscal son obligatorios'
        });
        return;
      }
    } else if (tipoPersona === 'F√≠sica') {
      const curp = req.body.curp || cliente.curp;
      if (!curp) {
        res.status(400).json({
          message: 'Para personas f√≠sicas, el CURP es obligatorio'
        });
        return;
      }
    }

    // Verificar si ya existe otro cliente con el mismo CURP, RFC o correo
    if (req.body.curp || req.body.rfc || req.body.correo || req.body.numIdentificacion) {
      const whereConditions: any[] = [];
      if (req.body.curp) whereConditions.push({ curp: req.body.curp });
      if (req.body.rfc) whereConditions.push({ rfc: req.body.rfc });
      if (req.body.correo) whereConditions.push({ correo: req.body.correo });
      if (req.body.numIdentificacion) whereConditions.push({ numIdentificacion: req.body.numIdentificacion });

      const existingCliente = await Cliente.findOne({
        where: {
          id: { [Op.ne]: req.params.id },
          [Op.or]: whereConditions
        } as WhereOptions
      });

      if (existingCliente) {
        res.status(400).json({
          message: 'Ya existe otro cliente con el mismo CURP, RFC, correo o n√∫mero de identificaci√≥n'
        });
        return;
      }
    }

    // Validar formato de RFC si es proporcionado
    if (req.body.rfc && !/^[A-Z&√ë]{3,4}[0-9]{6}[A-Z0-9]{3}$/.test(req.body.rfc)) {
      res.status(400).json({
        message: 'El formato del RFC no es v√°lido'
      });
      return;
    }

    // Validar formato de CURP si es proporcionado
    if (req.body.curp && !/^[A-Z]{4}[0-9]{6}[HM][A-Z]{5}[0-9A-Z][0-9]$/.test(req.body.curp)) {
      res.status(400).json({
        message: 'El formato del CURP no es v√°lido'
      });
      return;
    }

    await cliente.update(req.body);
    const clienteActualizado = await Cliente.findByPk(req.params.id, {
      include: ['tipoIdentificacion']
    });
    
    res.json(clienteActualizado);
  } catch (error) {
    console.error('Error al actualizar cliente:', error);
    if (error instanceof ValidationError) {
      res.status(400).json({ 
        message: 'Error de validaci√≥n', 
        errors: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      });
    } else {
      res.status(400).json({ message: 'Error al actualizar cliente', error });
    }
  }
};

// DELETE cliente
export const deleteCliente = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const cliente = await Cliente.findByPk(req.params.id);
    if (!cliente) {
      res.status(404).json({ message: 'Cliente no encontrado' });
      return;
    }
    await cliente.destroy();
    res.status(204).send();
  } catch (error) {
    console.error('Error al eliminar cliente:', error);
    res.status(500).json({ message: 'Error al eliminar cliente', error });
  }
};

// GET clientes by search term
export const searchClientes = async (req: Request<{}, {}, {}, { term: string }>, res: Response): Promise<void> => {
  try {
    const { term } = req.query;
    const clientes = await Cliente.findAll({
      where: {
        [Op.or]: [
          { nombre: { [Op.iLike]: `%${term}%` } },
          { curp: { [Op.iLike]: `%${term}%` } },
          { rfc: { [Op.iLike]: `%${term}%` } },
          { numIdentificacion: { [Op.iLike]: `%${term}%` } },
          { correo: { [Op.iLike]: `%${term}%` } },
          { razonSocial: { [Op.iLike]: `%${term}%` } }
        ]
      },
      include: ['tipoIdentificacion']
    });
    res.json(clientes);
  } catch (error) {
    console.error('Error al buscar clientes:', error);
    res.status(500).json({ message: 'Error al buscar clientes', error });
  }
};import { Request, Response } from 'express';
import { Credito } from '../models/credito.model';

export class CreditoController {
    // Obtener todos los cr√©ditos
    public async obtenerCreditos(req: Request, res: Response): Promise<void> {
        try {
            const creditos = await Credito.findAll({
                include: ['cliente', 'vehiculo']
            });
            res.status(200).json({
                success: true,
                data: creditos,
                message: 'Cr√©ditos obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los cr√©ditos',
                error: error
            });
        }
    }

    // Obtener un cr√©dito por ID
    public async obtenerCreditoPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id, {
                include: ['cliente', 'vehiculo']
            });
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Cr√©dito no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: credito,
                message: 'Cr√©dito obtenido exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener el cr√©dito',
                error: error
            });
        }
    }

    // Crear un nuevo cr√©dito
    public async crearCredito(req: Request, res: Response): Promise<void> {
        try {
            const nuevoCredito = await Credito.create(req.body);
            
            // Obtener el cr√©dito creado con sus relaciones
            const creditoConRelaciones = await Credito.findByPk(nuevoCredito.id, {
                include: ['cliente', 'vehiculo']
            });

            res.status(201).json({
                success: true,
                data: creditoConRelaciones,
                message: 'Cr√©dito creado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al crear el cr√©dito',
                error: error
            });
        }
    }

    // Actualizar un cr√©dito
    public async actualizarCredito(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id);
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Cr√©dito no encontrado'
                });
                return;
            }

            await credito.update(req.body);
            
            // Obtener el cr√©dito actualizado con sus relaciones
            const creditoActualizado = await Credito.findByPk(id, {
                include: ['cliente', 'vehiculo']
            });

            res.status(200).json({
                success: true,
                data: creditoActualizado,
                message: 'Cr√©dito actualizado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el cr√©dito',
                error: error
            });
        }
    }

    // Eliminar un cr√©dito
    public async eliminarCredito(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const credito = await Credito.findByPk(id);
            
            if (!credito) {
                res.status(404).json({
                    success: false,
                    message: 'Cr√©dito no encontrado'
                });
                return;
            }

            await credito.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Cr√©dito eliminado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el cr√©dito',
                error: error
            });
        }
    }

    // Obtener cr√©ditos por cliente
    public async obtenerCreditosPorCliente(req: Request, res: Response): Promise<void> {
        try {
            const { clienteId } = req.params;
            const creditos = await Credito.findAll({
                where: { clienteId },
                include: ['cliente', 'vehiculo']
            });

            res.status(200).json({
                success: true,
                data: creditos,
                message: 'Cr√©ditos del cliente obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los cr√©ditos del cliente',
                error: error
            });
        }
    }
}

export const creditoController = new CreditoController();import { Request, Response } from 'express';
import { Documento } from '../models/documento.model';

export class DocumentoController {
    // Obtener todos los documentos
    public async obtenerDocumentos(req: Request, res: Response): Promise<void> {
        try {
            const documentos = await Documento.findAll();
            res.status(200).json({
                success: true,
                data: documentos,
                message: 'Documentos obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los documentos',
                error: error
            });
        }
    }

    // Obtener documentos por empleado
    public async obtenerDocumentosPorEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { idEmpleado } = req.params;
            const documentos = await Documento.findAll({
                where: {
                    idEmpleado: idEmpleado
                }
            });
            
            // Verificar si hay documentos pendientes
            const documentosPendientes = documentos.some(doc => doc.estado === 'pendiente');
            
            res.status(200).json({
                success: true,
                data: {
                    documentosPendientes,
                    documentos
                },
                message: 'Documentos del empleado obtenidos exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener los documentos del empleado',
                error: error
            });
        }
    }

    // Obtener un documento por ID
    public async obtenerDocumentoPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento obtenido exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al obtener el documento',
                error: error
            });
        }
    }

    // Crear un nuevo documento
    public async crearDocumento(req: Request, res: Response): Promise<void> {
        try {
            const file = req.file;
            if (!file) {
                res.status(400).json({
                    success: false,
                    message: 'No se ha proporcionado ning√∫n archivo'
                });
                return;
            }
    
            const fileUrl = `/uploads/${file.filename}`;
            
            const nuevoDocumento = await Documento.create({
                ...req.body,
                url: fileUrl,
                estado: 'pendiente',
                fecha_subida: new Date()
            });
    
            res.status(201).json({
                success: true,
                data: nuevoDocumento,
                message: 'Documento creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear documento:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el documento',
                error: error
            });
        }
    }

    // Actualizar un documento
    public async actualizarDocumento(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            await documento.update(req.body);
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento actualizado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el documento',
                error: error
            });
        }
    }

    // Aprobar un documento
    public async aprobarDocumento(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            if (documento.estado !== 'pendiente') {
                res.status(400).json({
                    success: false,
                    message: 'El documento no est√° en estado pendiente'
                });
                return;
            }

            await documento.update({ estado: 'aprobado' });
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento aprobado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al aprobar el documento',
                error: error
            });
        }
    }

    // Rechazar un documento
    public async rechazarDocumento(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            if (documento.estado !== 'pendiente') {
                res.status(400).json({
                    success: false,
                    message: 'El documento no est√° en estado pendiente'
                });
                return;
            }

            await documento.update({ estado: 'rechazado' });
            
            res.status(200).json({
                success: true,
                data: documento,
                message: 'Documento rechazado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al rechazar el documento',
                error: error
            });
        }
    }

    // Eliminar un documento
    public async eliminarDocumento(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const documento = await Documento.findByPk(id);
            
            if (!documento) {
                res.status(404).json({
                    success: false,
                    message: 'Documento no encontrado'
                });
                return;
            }

            await documento.destroy();
            
            res.status(200).json({
                success: true,
                message: 'Documento eliminado exitosamente'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el documento',
                error: error
            });
        }
    }
}

export const documentoController = new DocumentoController();import { Request, Response } from 'express';
import { Usuario } from '../models/usuario.model';
import { Empleado } from '../models/empleado.model';
import { TipoIdentificacion } from '../models/catalogs/tipo-identificacion.model';
import { Op } from 'sequelize';
import bcrypt from 'bcrypt';

export class EmpleadoController {
    // Obtener todos los empleados con sus datos de usuario
    public async obtenerEmpleados(req: Request, res: Response): Promise<void> {
        try {
            const empleados = await Empleado.findAll({
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });
            
            res.status(200).json({
                success: true,
                data: empleados,
                message: 'Empleados obtenidos exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener empleados:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los empleados',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un empleado por ID
    public async obtenerEmpleadoPorId(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id_empleado: id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });
            
            if (!empleado) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: empleado,
                message: 'Empleado obtenido exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Crear un nuevo empleado junto con su usuario
    public async crearEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { usuario: usuarioData, empleado: empleadoData } = req.body;
            
            // Encriptar contrase√±a
            const salt = await bcrypt.genSalt(10);
            const hashedPassword = await bcrypt.hash(usuarioData.password, salt);

            // Crear usuario
            const nuevoUsuario = await Usuario.create({
                ...usuarioData,
                password: hashedPassword,
                is_active: true,
                is_locked: false
            });

            // Crear empleado asociado al usuario
            const nuevoEmpleado = await Empleado.create({
                ...empleadoData,
                id_usuario: nuevoUsuario.id
            });

            // Obtener el empleado con sus relaciones
            const empleadoCompleto = await Empleado.findOne({
                where: { id_empleado: nuevoEmpleado.id_empleado },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });

            res.status(201).json({
                success: true,
                data: empleadoCompleto,
                message: 'Empleado creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un empleado
    public async actualizarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { usuario: usuarioData, empleado: empleadoData } = req.body;

            const empleadoExistente = await Empleado.findOne({
                where: { id_empleado: id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario'
                    }
                ]
            });
            
            if (!empleadoExistente) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            // Actualizar datos del usuario si se proporcionan
            if (usuarioData && empleadoExistente.usuario) {
                const datosUsuario = { ...usuarioData };
                if (usuarioData.password) {
                    const salt = await bcrypt.genSalt(10);
                    datosUsuario.password = await bcrypt.hash(usuarioData.password, salt);
                }
                await Usuario.update(datosUsuario, {
                    where: { id_usuario: empleadoExistente.usuario.id }
                });
            }

            // Actualizar datos del empleado
            await empleadoExistente.update(empleadoData);

            // Obtener el empleado actualizado con sus relaciones
            const empleadoActualizado = await Empleado.findOne({
                where: { id_empleado: id },
                include: [
                    {
                        model: Usuario,
                        as: 'usuario',
                        attributes: { exclude: ['password'] }
                    },
                    {
                        model: TipoIdentificacion,
                        as: 'tipoIdentificacion'
                    }
                ]
            });

            res.status(200).json({
                success: true,
                data: empleadoActualizado,
                message: 'Empleado actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Desactivar un empleado (soft delete del usuario asociado)
    public async desactivarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id_empleado: id },
                include: [{ model: Usuario, as: 'usuario' }]
            });
            
            if (!empleado || !empleado.usuario) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            await Usuario.update(
                { is_active: false },
                { where: { id_usuario: empleado.usuario.id } }
            );
            
            res.status(200).json({
                success: true,
                message: 'Empleado desactivado exitosamente'
            });
        } catch (error) {
            console.error('Error al desactivar empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Reactivar un empleado
    public async reactivarEmpleado(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const empleado = await Empleado.findOne({
                where: { id_empleado: id },
                include: [{ model: Usuario, as: 'usuario' }]
            });
            
            if (!empleado || !empleado.usuario) {
                res.status(404).json({
                    success: false,
                    message: 'Empleado no encontrado'
                });
                return;
            }

            await Usuario.update(
                { is_active: true },
                { where: { id_usuario: empleado.usuario.id } }
            );
            
            res.status(200).json({
                success: true,
                message: 'Empleado reactivado exitosamente'
            });
        } catch (error) {
            console.error('Error al reactivar empleado:', error);
            res.status(500).json({
                success: false,
                message: 'Error al reactivar el empleado',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}

export const empleadoController = new EmpleadoController();import { Request, Response } from 'express';
import ScannerService from '../services/scanner.service';
import { ScanOptions } from '../config/scanner.config';
import * as fs from 'fs';
import * as path from 'path';

class ScannerController {
  private static instance: ScannerController;
  private scannerService: ScannerService;
  private configPath: string;

  private constructor() {
    this.scannerService = ScannerService.getInstance();
    this.configPath = path.join(process.cwd(), 'backend/src/config/scanner.config.ts');
  }

  public static getInstance(): ScannerController {
    if (!ScannerController.instance) {
      ScannerController.instance = new ScannerController();
    }
    return ScannerController.instance;
  }

  public async getStatus(_req: Request, res: Response): Promise<void> {
    try {
      const status = await this.scannerService.getScannerStatus();
      res.json({ status });
    } catch (error) {
      console.error('Error al obtener estado del esc√°ner:', error);
      res.status(500).json({ 
        error: 'Error al obtener estado del esc√°ner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async startScan(req: Request, res: Response): Promise<void> {
    try {
      const options: ScanOptions = {
        resolution: req.body.resolution || 300,
        colorMode: req.body.colorMode || 'Color',
        paperSize: req.body.paperSize || 'A4',
        outputFormat: req.body.outputFormat || 'PDF',
        duplex: req.body.duplex || false,
        brightness: req.body.brightness || 0,
        contrast: req.body.contrast || 0,
        documentId: req.body.documentId,
        clienteId: req.body.clienteId,
        tipoDocumento: req.body.tipoDocumento
      };

      const success = await this.scannerService.startScan(options);
      
      if (success) {
        res.json({ message: 'Escaneo iniciado correctamente' });
      } else {
        res.status(500).json({ error: 'Error al iniciar el escaneo' });
      }
    } catch (error) {
      console.error('Error al iniciar escaneo:', error);
      res.status(500).json({ 
        error: 'Error al iniciar escaneo',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async configure(req: Request, res: Response): Promise<void> {
    try {
      const currentConfig = {
        scannerIp: process.env.SCANNER_IP || '192.168.100.200',
        snmpCommunity: process.env.SNMP_COMMUNITY || 'public',
        uploadPath: process.env.SCANNER_UPLOAD_PATH || '/home/ubuntu/cliqueanet/backend/uploads/scanner'
      };

      if (req.method === 'GET') {
        res.json(currentConfig);
        return;
      }

      const newConfig = {
        scannerIp: req.body.scannerIp || currentConfig.scannerIp,
        snmpCommunity: req.body.snmpCommunity || currentConfig.snmpCommunity,
        uploadPath: req.body.uploadPath || currentConfig.uploadPath
      };

      // Actualizar variables de entorno
      process.env.SCANNER_IP = newConfig.scannerIp;
      process.env.SNMP_COMMUNITY = newConfig.snmpCommunity;
      process.env.SCANNER_UPLOAD_PATH = newConfig.uploadPath;

      // Asegurarse de que el directorio de uploads existe
      if (!fs.existsSync(newConfig.uploadPath)) {
        fs.mkdirSync(newConfig.uploadPath, { recursive: true });
      }

      // Reinicializar el servicio del esc√°ner con la nueva configuraci√≥n
      await this.scannerService.reinitialize(newConfig);

      res.json({
        message: 'Configuraci√≥n actualizada correctamente',
        config: newConfig
      });
    } catch (error) {
      console.error('Error al configurar esc√°ner:', error);
      res.status(500).json({ 
        error: 'Error al configurar esc√°ner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }

  public async testConnection(_req: Request, res: Response): Promise<void> {
    try {
      const status = await this.scannerService.getScannerStatus();
      if (status === 'READY' || status === 'BUSY') {
        res.json({ 
          connected: true,
          status,
          message: 'Conexi√≥n exitosa con el esc√°ner'
        });
      } else {
        res.status(503).json({ 
          connected: false,
          status,
          message: 'El esc√°ner no est√° disponible'
        });
      }
    } catch (error) {
      console.error('Error al probar conexi√≥n:', error);
      res.status(500).json({ 
        connected: false,
        error: 'Error al probar conexi√≥n con el esc√°ner',
        details: error instanceof Error ? error.message : 'Error desconocido'
      });
    }
  }
}

export default ScannerController;import { Request, Response } from 'express';
import { Transaccion } from '../models/transaccion.model';

// GET all transacciones
export const getAllTransacciones = async (_req: Request, res: Response): Promise<void> => {
  try {
    const transacciones = await Transaccion.findAll({
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    res.json(transacciones);
  } catch (error) {
    console.error('Error al obtener transacciones:', error);
    res.status(500).json({ message: 'Error al obtener transacciones', error });
  }
};

// GET transaccion by ID
export const getTransaccionById = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    if (!transaccion) {
      res.status(404).json({ message: 'Transacci√≥n no encontrada' });
      return;
    }
    res.json(transaccion);
  } catch (error) {
    console.error('Error al obtener transacci√≥n:', error);
    res.status(500).json({ message: 'Error al obtener transacci√≥n', error });
  }
};

// POST create new transaccion
export const createTransaccion = async (req: Request, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.create({
      ...req.body,
      fecha: new Date()
    });
    
    const transaccionConRelaciones = await Transaccion.findByPk(transaccion.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    
    res.status(201).json(transaccionConRelaciones);
  } catch (error) {
    console.error('Error al crear transacci√≥n:', error);
    res.status(400).json({ message: 'Error al crear transacci√≥n', error });
  }
};

// PUT update transaccion
export const updateTransaccion = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id);
    if (!transaccion) {
      res.status(404).json({ message: 'Transacci√≥n no encontrada' });
      return;
    }

    await transaccion.update(req.body);
    
    const transaccionActualizada = await Transaccion.findByPk(req.params.id, {
      include: ['usuarioTransaccion', 'cliente', 'vehiculo', 'credito', 'tipoTransaccion']
    });
    
    res.json(transaccionActualizada);
  } catch (error) {
    console.error('Error al actualizar transacci√≥n:', error);
    res.status(400).json({ message: 'Error al actualizar transacci√≥n', error });
  }
};

// DELETE transaccion
export const deleteTransaccion = async (req: Request<{ id: string }>, res: Response): Promise<void> => {
  try {
    const transaccion = await Transaccion.findByPk(req.params.id);
    if (!transaccion) {
      res.status(404).json({ message: 'Transacci√≥n no encontrada' });
      return;
    }
    await transaccion.destroy();
    res.status(204).send();
  } catch (error) {
    console.error('Error al eliminar transacci√≥n:', error);
    res.status(500).json({ message: 'Error al eliminar transacci√≥n', error });
  }
};import { Request, Response } from 'express';
import Usuario from '../models/usuario.model';
import { CreateUsuario, UpdateUsuario, LoginCredentials, RolUsuario } from '../types';
import { hashPassword } from '../middlewares/auth.middleware';

export class UsuarioController {
  login = async (req: Request, res: Response): Promise<void> => {
    try {
      console.log('üöÄ Login request received:', req.body);
      const credentials: LoginCredentials = {
        ...req.body,
        ip_address: req.realIP // Usar la IP real del middleware
      };
      
      // Validar que se proporcione al menos un m√©todo de identificaci√≥n
      if (!credentials.employeeId && !credentials.correo) {
        console.log('‚ùå No se proporcion√≥ m√©todo de identificaci√≥n');
        res.status(400).json({
          success: false,
          message: 'Debe proporcionar un n√∫mero de empleado o correo electr√≥nico'
        });
        return;
      }

      // Validar contrase√±a
      if (!credentials.password) {
        console.log('‚ùå No se proporcion√≥ contrase√±a');
        res.status(400).json({
          success: false,
          message: 'Debe proporcionar una contrase√±a'
        });
        return;
      }

      console.log('‚úÖ Validaciones pasadas, intentando login');
      const result = await Usuario.login(credentials);

      if (!result) {
        console.log('‚ùå Login fallido: credenciales inv√°lidas');
        res.status(401).json({
          success: false,
          message: 'Credenciales inv√°lidas'
        });
        return;
      }

      console.log('‚úÖ Login exitoso');
      res.status(200).json({
        success: true,
        data: result,
        message: 'Login exitoso'
      });
    } catch (error) {
      console.error('‚ùå Error en el proceso de login:', error);
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error en el proceso de login'
      });
    }
  };

  crearUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const usuarioData: CreateUsuario = req.body;

      // Validar contrase√±a
      if (!/^(?=.*[A-Z])(?=.*\d).{8,}$/.test(usuarioData.password)) {
        res.status(400).json({
          success: false,
          message: 'La contrase√±a debe tener al menos 8 caracteres, una may√∫scula y un n√∫mero'
        });
        return;
      }

      // Hash de la contrase√±a
      usuarioData.password = await hashPassword(usuarioData.password);
      
      const nuevoUsuario = await Usuario.create(usuarioData);
      
      // Excluir la contrase√±a de la respuesta
      const { password, ...usuarioSinPassword } = nuevoUsuario.toJSON();
      
      res.status(201).json({
        success: true,
        data: usuarioSinPassword,
        message: 'Usuario creado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al crear usuario'
      });
    }
  };

  obtenerUsuarioPorId = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const usuario = await Usuario.findByPk(id, {
        attributes: { exclude: ['password'] }
      });
      
      if (!usuario) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: usuario
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al obtener usuario'
      });
    }
  };

  obtenerTodosUsuarios = async (_req: Request, res: Response): Promise<void> => {
    try {
      const usuarios = await Usuario.findAll({
        attributes: { exclude: ['password'] }
      });
      res.status(200).json({
        success: true,
        data: usuarios
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al obtener usuarios'
      });
    }
  };

  actualizarUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const usuarioData: UpdateUsuario = req.body;

      // Si se actualiza la contrase√±a, validar y hashear
      if (usuarioData.password) {
        if (!/^(?=.*[A-Z])(?=.*\d).{8,}$/.test(usuarioData.password)) {
          res.status(400).json({
            success: false,
            message: 'La contrase√±a debe tener al menos 8 caracteres, una may√∫scula y un n√∫mero'
          });
          return;
        }
        usuarioData.password = await hashPassword(usuarioData.password);
      }

      const [numRows, [usuarioActualizado]] = await Usuario.update(usuarioData, {
        where: { id_empleado: id },
        returning: true
      });

      if (numRows === 0) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }

      // Excluir la contrase√±a de la respuesta
      const { password, ...usuarioSinPassword } = usuarioActualizado.toJSON();
      
      res.status(200).json({
        success: true,
        data: usuarioSinPassword,
        message: 'Usuario actualizado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al actualizar usuario'
      });
    }
  };

  eliminarUsuario = async (req: Request, res: Response): Promise<void> => {
    try {
      const id = parseInt(req.params.id);
      const numRows = await Usuario.destroy({
        where: { id_empleado: id }
      });
      
      if (numRows === 0) {
        res.status(404).json({
          success: false,
          message: `Usuario con ID ${id} no encontrado`
        });
        return;
      }
      
      res.status(200).json({
        success: true,
        message: 'Usuario eliminado exitosamente'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al eliminar usuario'
      });
    }
  };

  buscarUsuariosPorRol = async (req: Request, res: Response): Promise<void> => {
    try {
      const rolId = parseInt(req.params.rol);
      if (isNaN(rolId) || !Object.values(RolUsuario).includes(rolId)) {
        res.status(400).json({
          success: false,
          message: 'Rol inv√°lido'
        });
        return;
      }

      const usuarios = await Usuario.findAll({
        where: { id_rol: rolId },
        attributes: { exclude: ['password'] }
      });
      
      res.status(200).json({
        success: true,
        data: usuarios
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al buscar usuarios por rol'
      });
    }
  };

  buscarUsuarioPorCorreo = async (req: Request, res: Response): Promise<void> => {
    try {
      const { correo } = req.params;
      const usuario = await Usuario.findOne({
        where: { correo },
        attributes: { exclude: ['password'] }
      });
      
      if (!usuario) {
        res.status(404).json({
          success: false,
          message: `Usuario con correo ${correo} no encontrado`
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: usuario
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: (error as Error).message,
        message: 'Error al buscar usuario por correo'
      });
    }
  };
}import { Request, Response } from 'express';
import { Vehiculo } from '../models/vehiculo.model';
import { Op } from 'sequelize';

export class VehiculoController {
    
    // Crear un nuevo veh√≠culo
    public async create(req: Request, res: Response): Promise<void> {
        try {
            const {
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            } = req.body;

            // Validar campos requeridos
            if (!marca || !modelo || !anio || !precio || !numSerie || !color || !numMotor) {
                res.status(400).json({
                    success: false,
                    message: 'Todos los campos obligatorios deben ser proporcionados'
                });
                return;
            }

            const vehiculo = await Vehiculo.create({
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            });

            res.status(201).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear veh√≠culo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener todos los veh√≠culos
    public async getAll(req: Request, res: Response): Promise<void> {
        try {
            const vehiculos = await Vehiculo.findAll();
            res.status(200).json({
                success: true,
                data: vehiculos,
                message: 'Veh√≠culos recuperados exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener veh√≠culos:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los veh√≠culos',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un veh√≠culo por ID
    public async getById(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener veh√≠culo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener veh√≠culo por n√∫mero de serie
    public async getByNumSerie(req: Request, res: Response): Promise<void> {
        try {
            const { numSerie } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { numSerie }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener veh√≠culo por n√∫mero de serie:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener veh√≠culo por placas
    public async getByPlacas(req: Request, res: Response): Promise<void> {
        try {
            const { placas } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { placas }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener veh√≠culo por placas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener veh√≠culo por n√∫mero de motor
    public async getByNumMotor(req: Request, res: Response): Promise<void> {
        try {
            const { numMotor } = req.query;
            const vehiculo = await Vehiculo.findOne({
                where: { numMotor }
            });

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener veh√≠culo por n√∫mero de motor:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un veh√≠culo
    public async update(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            const {
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            } = req.body;

            // Validar campos requeridos
            if (!marca || !modelo || !anio || !precio || !numSerie || !color || !numMotor) {
                res.status(400).json({
                    success: false,
                    message: 'Todos los campos obligatorios deben ser proporcionados'
                });
                return;
            }

            await vehiculo.update({
                marca,
                modelo,
                anio,
                precio,
                numSerie,
                color,
                numMotor,
                numFactura,
                placas,
                tarjetaCirculacion,
                comentariosInternos
            });

            res.status(200).json({
                success: true,
                data: vehiculo,
                message: 'Veh√≠culo actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar veh√≠culo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Eliminar un veh√≠culo
    public async delete(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const vehiculo = await Vehiculo.findByPk(id);

            if (!vehiculo) {
                res.status(404).json({
                    success: false,
                    message: 'Veh√≠culo no encontrado'
                });
                return;
            }

            await vehiculo.destroy();

            res.status(200).json({
                success: true,
                message: 'Veh√≠culo eliminado exitosamente'
            });
        } catch (error) {
            console.error('Error al eliminar veh√≠culo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el veh√≠culo',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}import { Request, Response } from 'express';
import { Op } from 'sequelize';
import { RolUsuario } from '../../models/catalogs/rol-usuario.model';
import { Usuario } from '../../models/usuario.model';

export class RolUsuarioController {
    
    // Crear un nuevo rol de usuario
    public async create(req: Request, res: Response): Promise<void> {
        try {
            const { nombre } = req.body;

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe un rol con el mismo nombre
            const existingRol = await RolUsuario.findOne({ where: { nombre } });
            if (existingRol) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe un rol con este nombre'
                });
                return;
            }

            const rolUsuario = await RolUsuario.create({ nombre });

            res.status(201).json({
                success: true,
                data: rolUsuario,
                message: 'Rol de usuario creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear rol de usuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el rol de usuario',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener todos los roles de usuario
    public async getAll(req: Request, res: Response): Promise<void> {
        try {
            const rolesUsuario = await RolUsuario.findAll({
                order: [['nombre', 'ASC']]
            });

            res.status(200).json({
                success: true,
                data: rolesUsuario,
                message: 'Roles de usuario recuperados exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener roles de usuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los roles de usuario',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un rol de usuario por ID
    public async getById(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const rolUsuario = await RolUsuario.findByPk(id);

            if (!rolUsuario) {
                res.status(404).json({
                    success: false,
                    message: 'Rol de usuario no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: rolUsuario,
                message: 'Rol de usuario recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener rol de usuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el rol de usuario',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un rol de usuario
    public async update(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { nombre } = req.body;

            const rolUsuario = await RolUsuario.findByPk(id);

            if (!rolUsuario) {
                res.status(404).json({
                    success: false,
                    message: 'Rol de usuario no encontrado'
                });
                return;
            }

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe otro rol con el mismo nombre
            const existingRol = await RolUsuario.findOne({
                where: { 
                    nombre,
                    id: { [Op.ne]: id } // Excluir el registro actual
                }
            });

            if (existingRol) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe otro rol con este nombre'
                });
                return;
            }

            await rolUsuario.update({ nombre });

            res.status(200).json({
                success: true,
                data: rolUsuario,
                message: 'Rol de usuario actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar rol de usuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el rol de usuario',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Eliminar un rol de usuario
    public async delete(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const rolUsuario = await RolUsuario.findByPk(id);

            if (!rolUsuario) {
                res.status(404).json({
                    success: false,
                    message: 'Rol de usuario no encontrado'
                });
                return;
            }

            // Verificar si el rol est√° siendo usado por alg√∫n usuario
            const usuariosAsociados = await Usuario.count({
                where: { id_rol: id }
            });

            if (usuariosAsociados > 0) {
                res.status(400).json({
                    success: false,
                    message: 'No se puede eliminar el rol porque est√° siendo usado por usuarios existentes'
                });
                return;
            }

            await rolUsuario.destroy();

            res.status(200).json({
                success: true,
                message: 'Rol de usuario eliminado exitosamente'
            });
        } catch (error) {
            console.error('Error al eliminar rol de usuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el rol de usuario',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}import { Request, Response } from 'express';
import { Op } from 'sequelize';
import { TipoIdentificacion } from '../../models/catalogs/tipo-identificacion.model';
import { Usuario } from '../../models/usuario.model';
import { Cliente } from '../../models/cliente.model';

export class TipoIdentificacionController {
    
    // Crear un nuevo tipo de identificaci√≥n
    public async create(req: Request, res: Response): Promise<void> {
        try {
            const { nombre, descripcion } = req.body;

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe un tipo con el mismo nombre
            const existingTipo = await TipoIdentificacion.findOne({ where: { nombre } });
            if (existingTipo) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe un tipo de identificaci√≥n con este nombre'
                });
                return;
            }

            const tipoIdentificacion = await TipoIdentificacion.create({
                nombre,
                descripcion
            });

            res.status(201).json({
                success: true,
                data: tipoIdentificacion,
                message: 'Tipo de identificaci√≥n creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear tipo de identificaci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el tipo de identificaci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener todos los tipos de identificaci√≥n
    public async getAll(req: Request, res: Response): Promise<void> {
        try {
            const tiposIdentificacion = await TipoIdentificacion.findAll({
                order: [['nombre', 'ASC']]
            });

            res.status(200).json({
                success: true,
                data: tiposIdentificacion,
                message: 'Tipos de identificaci√≥n recuperados exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener tipos de identificaci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los tipos de identificaci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un tipo de identificaci√≥n por ID
    public async getById(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const tipoIdentificacion = await TipoIdentificacion.findByPk(id);

            if (!tipoIdentificacion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de identificaci√≥n no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: tipoIdentificacion,
                message: 'Tipo de identificaci√≥n recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener tipo de identificaci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el tipo de identificaci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un tipo de identificaci√≥n
    public async update(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { nombre, descripcion } = req.body;

            const tipoIdentificacion = await TipoIdentificacion.findByPk(id);

            if (!tipoIdentificacion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de identificaci√≥n no encontrado'
                });
                return;
            }

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe otro tipo con el mismo nombre
            const existingTipo = await TipoIdentificacion.findOne({
                where: { 
                    nombre,
                    id: { [Op.ne]: id } // Excluir el registro actual
                }
            });

            if (existingTipo) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe otro tipo de identificaci√≥n con este nombre'
                });
                return;
            }

            await tipoIdentificacion.update({
                nombre,
                descripcion
            });

            res.status(200).json({
                success: true,
                data: tipoIdentificacion,
                message: 'Tipo de identificaci√≥n actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar tipo de identificaci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el tipo de identificaci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Eliminar un tipo de identificaci√≥n
    public async delete(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const tipoIdentificacion = await TipoIdentificacion.findByPk(id);

            if (!tipoIdentificacion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de identificaci√≥n no encontrado'
                });
                return;
            }

            // Verificar si el tipo est√° siendo usado por alg√∫n usuario o cliente
            const usuariosAsociados = await Usuario.count({
                where: { id_tipo_identificacion: id }
            });

            const clientesAsociados = await Cliente.count({
                where: { id_tipo_identificacion: id }
            });

            if (usuariosAsociados > 0 || clientesAsociados > 0) {
                res.status(400).json({
                    success: false,
                    message: 'No se puede eliminar el tipo de identificaci√≥n porque est√° siendo usado por usuarios o clientes existentes'
                });
                return;
            }

            await tipoIdentificacion.destroy();

            res.status(200).json({
                success: true,
                message: 'Tipo de identificaci√≥n eliminado exitosamente'
            });
        } catch (error) {
            console.error('Error al eliminar tipo de identificaci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el tipo de identificaci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}import { Request, Response } from 'express';
import { Op } from 'sequelize';
import { TipoTransaccion } from '../../models/catalogs/tipo-transaccion.model';
import { Transaccion } from '../../models/transaccion.model';

export class TipoTransaccionController {
    
    // Crear un nuevo tipo de transacci√≥n
    public async create(req: Request, res: Response): Promise<void> {
        try {
            const { nombre } = req.body;

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe un tipo con el mismo nombre
            const existingTipo = await TipoTransaccion.findOne({ where: { nombre } });
            if (existingTipo) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe un tipo de transacci√≥n con este nombre'
                });
                return;
            }

            const tipoTransaccion = await TipoTransaccion.create({ nombre });

            res.status(201).json({
                success: true,
                data: tipoTransaccion,
                message: 'Tipo de transacci√≥n creado exitosamente'
            });
        } catch (error) {
            console.error('Error al crear tipo de transacci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear el tipo de transacci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener todos los tipos de transacci√≥n
    public async getAll(req: Request, res: Response): Promise<void> {
        try {
            const tiposTransaccion = await TipoTransaccion.findAll({
                order: [['nombre', 'ASC']]
            });

            res.status(200).json({
                success: true,
                data: tiposTransaccion,
                message: 'Tipos de transacci√≥n recuperados exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener tipos de transacci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener los tipos de transacci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Obtener un tipo de transacci√≥n por ID
    public async getById(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const tipoTransaccion = await TipoTransaccion.findByPk(id);

            if (!tipoTransaccion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de transacci√≥n no encontrado'
                });
                return;
            }

            res.status(200).json({
                success: true,
                data: tipoTransaccion,
                message: 'Tipo de transacci√≥n recuperado exitosamente'
            });
        } catch (error) {
            console.error('Error al obtener tipo de transacci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener el tipo de transacci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Actualizar un tipo de transacci√≥n
    public async update(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const { nombre } = req.body;

            const tipoTransaccion = await TipoTransaccion.findByPk(id);

            if (!tipoTransaccion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de transacci√≥n no encontrado'
                });
                return;
            }

            // Validar campo requerido
            if (!nombre) {
                res.status(400).json({
                    success: false,
                    message: 'El nombre es requerido'
                });
                return;
            }

            // Verificar si ya existe otro tipo con el mismo nombre
            const existingTipo = await TipoTransaccion.findOne({
                where: { 
                    nombre,
                    id: { [Op.ne]: id } // Excluir el registro actual
                }
            });

            if (existingTipo) {
                res.status(400).json({
                    success: false,
                    message: 'Ya existe otro tipo de transacci√≥n con este nombre'
                });
                return;
            }

            await tipoTransaccion.update({ nombre });

            res.status(200).json({
                success: true,
                data: tipoTransaccion,
                message: 'Tipo de transacci√≥n actualizado exitosamente'
            });
        } catch (error) {
            console.error('Error al actualizar tipo de transacci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el tipo de transacci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }

    // Eliminar un tipo de transacci√≥n
    public async delete(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const tipoTransaccion = await TipoTransaccion.findByPk(id);

            if (!tipoTransaccion) {
                res.status(404).json({
                    success: false,
                    message: 'Tipo de transacci√≥n no encontrado'
                });
                return;
            }

            // Verificar si el tipo est√° siendo usado en alguna transacci√≥n
            const transaccionesAsociadas = await Transaccion.count({
                where: { id_tipo_transaccion: id }
            });

            if (transaccionesAsociadas > 0) {
                res.status(400).json({
                    success: false,
                    message: 'No se puede eliminar el tipo de transacci√≥n porque est√° siendo usado en transacciones existentes'
                });
                return;
            }

            await tipoTransaccion.destroy();

            res.status(200).json({
                success: true,
                message: 'Tipo de transacci√≥n eliminado exitosamente'
            });
        } catch (error) {
            console.error('Error al eliminar tipo de transacci√≥n:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar el tipo de transacci√≥n',
                error: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    }
}import { Router, Request, Response, NextFunction } from 'express';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';

const router = Router();

// Middleware de autenticaci√≥n y rol
const autenticarYVerificarRol = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador, RolUsuario.Ventas])(req, res, next);
    });
};

// Rutas p√∫blicas
router.get('/', (req: Request, res: Response) => {
    res.json({ message: 'Ruta de citas' });
});

// Rutas protegidas
// Obtener todas las citas
router.get('/list', autenticarYVerificarRol, (req: Request, res: Response) => {
    res.json({ message: 'Lista de citas' });
});

// Obtener una cita por ID
router.get('/:id', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Obtener cita por ID: ${id}` });
});

// Crear una nueva cita
router.post('/', autenticarYVerificarRol, (req: Request, res: Response) => {
    const citaData = req.body;
    res.json({ message: 'Crear cita', data: citaData });
});

// Actualizar una cita
router.put('/:id', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { id } = req.params;
    const citaData = req.body;
    res.json({ message: `Actualizar cita: ${id}`, data: citaData });
});

// Eliminar una cita
router.delete('/:id', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Eliminar cita: ${id}` });
});

export default router;import { Router } from 'express';
import {
  getAllClientes,
  getClienteById,
  createCliente,
  updateCliente,
  deleteCliente,
  searchClientes
} from '../controllers/cliente.controller';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';

const router = Router();

// Aplicar verificaci√≥n de token a todas las rutas
router.use(verificarToken);

// Rutas p√∫blicas (solo requieren token)
router.get('/', getAllClientes);
router.get('/search', searchClientes);
router.get('/:id', getClienteById);

// Rutas que requieren roles espec√≠ficos
router.post('/', verificarRol([RolUsuario.Administrador, RolUsuario.Ventas]), createCliente);
router.put('/:id', verificarRol([RolUsuario.Administrador, RolUsuario.Ventas]), updateCliente);
router.delete('/:id', verificarRol([RolUsuario.Administrador]), deleteCliente);

export default router;import { Router, RequestHandler } from 'express';
import { Credito } from '../models/credito.model';

const router = Router();

// GET all creditos
const getAllCreditos: RequestHandler = async (_req, res) => {
  try {
    const creditos = await Credito.findAll();
    res.json(creditos);
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener cr√©ditos', error });
  }
};

// GET credito by ID
const getCreditoById: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const credito = await Credito.findByPk(req.params.id);
    if (!credito) {
      res.status(404).json({ message: 'Cr√©dito no encontrado' });
    } else {
      res.json(credito);
    }
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener cr√©dito', error });
  }
};

// POST create new credito
const createCredito: RequestHandler = async (req, res) => {
  try {
    const credito = await Credito.create(req.body);
    res.status(201).json(credito);
  } catch (error) {
    res.status(400).json({ message: 'Error al crear cr√©dito', error });
  }
};

// PUT update credito
const updateCredito: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const credito = await Credito.findByPk(req.params.id);
    if (!credito) {
      res.status(404).json({ message: 'Cr√©dito no encontrado' });
    } else {
      await credito.update(req.body);
      res.json(credito);
    }
  } catch (error) {
    res.status(400).json({ message: 'Error al actualizar cr√©dito', error });
  }
};

// DELETE credito
const deleteCredito: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const credito = await Credito.findByPk(req.params.id);
    if (!credito) {
      res.status(404).json({ message: 'Cr√©dito no encontrado' });
    } else {
      await credito.destroy();
      res.status(204).send();
    }
  } catch (error) {
    res.status(500).json({ message: 'Error al eliminar cr√©dito', error });
  }
};

// Route definitions
router.get('/', getAllCreditos);
router.get('/:id', getCreditoById);
router.post('/', createCredito);
router.put('/:id', updateCredito);
router.delete('/:id', deleteCredito);

export default router;import { Router, Request, Response, NextFunction } from 'express';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';
import { documentoController } from '../controllers/documento.controller';
import { upload } from '../middlewares/upload.middleware';

const router = Router();

// Middleware de autenticaci√≥n y rol
const autenticarYVerificarRol = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador, RolUsuario.Ventas, RolUsuario.RRHH])(req, res, next);
    });
};

// Middleware solo para admin
const verificarAdmin = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador])(req, res, next);
    });
};

// Rutas protegidas
// Obtener todos los documentos
router.get('/list', autenticarYVerificarRol, documentoController.obtenerDocumentos.bind(documentoController));

// Obtener documentos por empleado
router.get('/empleado/:idEmpleado', autenticarYVerificarRol, documentoController.obtenerDocumentosPorEmpleado.bind(documentoController));

// Obtener un documento por ID
router.get('/:id', autenticarYVerificarRol, documentoController.obtenerDocumentoPorId.bind(documentoController));

// Crear un nuevo documento
router.post('/', 
    autenticarYVerificarRol, 
    upload.single('file'), 
    documentoController.crearDocumento.bind(documentoController)
  );

// Actualizar informaci√≥n de un documento
router.put('/:id', autenticarYVerificarRol, documentoController.actualizarDocumento.bind(documentoController));

// Eliminar un documento (solo admin)
router.delete('/:id', verificarAdmin, documentoController.eliminarDocumento.bind(documentoController));

// Aprobar un documento (solo admin)
router.post('/:id/aprobar', verificarAdmin, documentoController.aprobarDocumento.bind(documentoController));

// Rechazar un documento (solo admin)
router.post('/:id/rechazar', verificarAdmin, documentoController.rechazarDocumento.bind(documentoController));

// Obtener documentos por entidad
router.get('/entidad/:tipo/:id', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { tipo, id } = req.params;
    res.json({ message: `Obtener documentos de ${tipo} con ID: ${id}` });
});

// Obtener documentos por categor√≠a
router.get('/categoria/:categoria', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { categoria } = req.params;
    res.json({ message: `Obtener documentos de categor√≠a: ${categoria}` });
});

// Verificar documento (solo admin)
router.post('/:id/verificar', verificarAdmin, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Verificar documento: ${id}` });
});

// Obtener historial de cambios de un documento
router.get('/:id/historial', autenticarYVerificarRol, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Obtener historial del documento: ${id}` });
});

// Buscar documentos
router.post('/buscar', autenticarYVerificarRol, (req: Request, res: Response) => {
    const filtros = req.body;
    res.json({ message: 'Buscar documentos', filtros });
});

export default router;import { Router } from 'express';
import { empleadoController } from '../controllers/empleado.controller';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';
import { Request, Response, NextFunction } from 'express';

const router = Router();

// Definir los roles permitidos
const rolesPermitidos = [RolUsuario.Administrador, RolUsuario.Gerente_general];

// Middleware de autenticaci√≥n para todas las rutas
router.use(async (req: Request, res: Response, next: NextFunction) => {
    try {
        await verificarToken(req, res, next);
    } catch (error) {
        next(error);
    }
});

// Middleware de verificaci√≥n de rol
const checkRol = async (req: Request, res: Response, next: NextFunction) => {
    try {
        await verificarRol(rolesPermitidos)(req, res, next);
    } catch (error) {
        next(error);
    }
};

// Rutas para empleados
router.get('/', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.obtenerEmpleados(req, res);
    } catch (error) {
        next(error);
    }
});

router.get('/:id', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.obtenerEmpleadoPorId(req, res);
    } catch (error) {
        next(error);
    }
});

router.post('/', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.crearEmpleado(req, res);
    } catch (error) {
        next(error);
    }
});

router.put('/:id', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.actualizarEmpleado(req, res);
    } catch (error) {
        next(error);
    }
});

router.put('/:id/desactivar', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.desactivarEmpleado(req, res);
    } catch (error) {
        next(error);
    }
});

router.put('/:id/reactivar', checkRol, async (req: Request, res: Response, next: NextFunction) => {
    try {
        await empleadoController.reactivarEmpleado(req, res);
    } catch (error) {
        next(error);
    }
});

export default router;import { Router, Request, Response, NextFunction } from 'express';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';

const router = Router();

// Middleware de autenticaci√≥n y rol para RRHH y Admin
const autenticarYVerificarRolNomina = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador, RolUsuario.RRHH])(req, res, next);
    });
};

// Middleware solo para admin
const verificarAdmin = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador])(req, res, next);
    });
};

// Rutas protegidas
// Obtener todas las n√≥minas
router.get('/list', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    res.json({ message: 'Lista de n√≥minas' });
});

// Obtener una n√≥mina por ID
router.get('/:id', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Obtener n√≥mina por ID: ${id}` });
});

// Crear una nueva n√≥mina
router.post('/', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const nominaData = req.body;
    res.json({ message: 'Crear n√≥mina', data: nominaData });
});

// Actualizar una n√≥mina (solo admin)
router.put('/:id', verificarAdmin, (req: Request, res: Response) => {
    const { id } = req.params;
    const nominaData = req.body;
    res.json({ message: `Actualizar n√≥mina: ${id}`, data: nominaData });
});

// Registrar pago de n√≥mina
router.post('/:id/pago', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { id } = req.params;
    const pagoData = req.body;
    res.json({ message: `Registrar pago de n√≥mina: ${id}`, data: pagoData });
});

// Registrar comisiones
router.post('/:id/comisiones', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { id } = req.params;
    const comisionesData = req.body;
    res.json({ message: `Registrar comisiones para n√≥mina: ${id}`, data: comisionesData });
});

// Obtener n√≥minas por empleado
router.get('/empleado/:empleadoId', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { empleadoId } = req.params;
    res.json({ message: `Obtener n√≥minas del empleado: ${empleadoId}` });
});

// Obtener n√≥minas por per√≠odo
router.get('/periodo/:inicio/:fin', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { inicio, fin } = req.params;
    res.json({ message: `Obtener n√≥minas del per√≠odo: ${inicio} al ${fin}` });
});

// Generar reporte de n√≥mina
router.post('/reporte', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const filtros = req.body;
    res.json({ message: 'Generar reporte de n√≥minas', filtros });
});

// Calcular deducciones
router.post('/:id/deducciones', autenticarYVerificarRolNomina, (req: Request, res: Response) => {
    const { id } = req.params;
    const deduccionesData = req.body;
    res.json({ message: `Calcular deducciones para n√≥mina: ${id}`, data: deduccionesData });
});

// Aprobar n√≥mina (solo admin)
router.post('/:id/aprobar', verificarAdmin, (req: Request, res: Response) => {
    const { id } = req.params;
    res.json({ message: `Aprobar n√≥mina: ${id}` });
});

export default router;import { Router, Request, Response, NextFunction } from 'express';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import ScannerController from '../controllers/scanner.controller';
import { RolUsuario } from '../types';

const router = Router();
const scannerController = ScannerController.getInstance();

// Middleware de autenticaci√≥n y rol
const autenticarYVerificarRol = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador, RolUsuario.Ventas])(req, res, next);
    });
};

// Middleware solo para admin
const verificarAdmin = (req: Request, res: Response, next: NextFunction) => {
    verificarToken(req, res, () => {
        verificarRol([RolUsuario.Administrador])(req, res, next);
    });
};

// Rutas protegidas
router.get('/status', autenticarYVerificarRol, scannerController.getStatus.bind(scannerController));
router.post('/scan', autenticarYVerificarRol, scannerController.startScan.bind(scannerController));
router.post('/configure', verificarAdmin, scannerController.configure.bind(scannerController));
router.get('/test-connection', autenticarYVerificarRol, scannerController.testConnection.bind(scannerController));

export default router;import { Router } from 'express';
import {
  getAllTransacciones,
  getTransaccionById,
  createTransaccion,
  updateTransaccion,
  deleteTransaccion
} from '../controllers/transaccion.controller';

const router = Router();

// Route definitions
router.get('/', getAllTransacciones);
router.get('/:id', getTransaccionById);
router.post('/', createTransaccion);
router.put('/:id', updateTransaccion);
router.delete('/:id', deleteTransaccion);

export default router;import { Router } from 'express';
import { UsuarioController } from '../controllers/usuario.controller';
import { verificarToken, verificarRol } from '../middlewares/auth.middleware';
import { RolUsuario } from '../types';

const router = Router();
const controller = new UsuarioController();

// Rutas p√∫blicas
router.post('/login', controller.login);

// Rutas protegidas - requieren autenticaci√≥n
router.use(verificarToken);

// Rutas para administradores y RRHH
router.post('/', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH]), 
  controller.crearUsuario
);

router.get('/', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH, RolUsuario.Gerente_general]), 
  controller.obtenerTodosUsuarios
);

router.get('/:id', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH, RolUsuario.Gerente_general]), 
  controller.obtenerUsuarioPorId
);

router.put('/:id', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH]), 
  controller.actualizarUsuario
);

router.delete('/:id', 
  verificarRol([RolUsuario.Administrador]), 
  controller.eliminarUsuario
);

// Rutas adicionales
router.get('/rol/:rol', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH, RolUsuario.Gerente_general]), 
  controller.buscarUsuariosPorRol
);

router.get('/correo/:correo', 
  verificarRol([RolUsuario.Administrador, RolUsuario.RRHH]), 
  controller.buscarUsuarioPorCorreo
);

export default router;import { Router } from 'express';
import { VehiculoController } from '../controllers/vehiculo.controller';

const router = Router();
const controller = new VehiculoController();

// GET all vehiculos
router.get('/', controller.getAll.bind(controller));

// GET vehiculo by ID
router.get('/:id', controller.getById.bind(controller));

// GET vehiculo by filters (num_serie, placas, num_motor)
router.get('/search/filters', async (req, res) => {
    const { numSerie, placas, numMotor } = req.query;

    try {
        if (numSerie) {
            await controller.getByNumSerie(req, res);
            return;
        }
        
        if (placas) {
            await controller.getByPlacas(req, res);
            return;
        }
        
        if (numMotor) {
            await controller.getByNumMotor(req, res);
            return;
        }

        res.status(400).json({
            success: false,
            message: 'Se debe proporcionar al menos un criterio de b√∫squeda (numSerie, placas o numMotor)'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Error al buscar veh√≠culos',
            error: error instanceof Error ? error.message : 'Error desconocido'
        });
    }
});

// POST create new vehiculo
router.post('/', controller.create.bind(controller));

// PUT update vehiculo
router.put('/:id', controller.update.bind(controller));

// DELETE vehiculo
router.delete('/:id', controller.delete.bind(controller));

export default router;import { Router, RequestHandler } from 'express';
import { Venta } from '../models/venta.model';

const router = Router();

// GET all ventas
const getAllVentas: RequestHandler = async (_req, res) => {
  try {
    const ventas = await Venta.findAll();
    res.json(ventas);
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener ventas', error });
  }
};

// GET venta by ID
const getVentaById: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const venta = await Venta.findByPk(req.params.id);
    if (!venta) {
      res.status(404).json({ message: 'Venta no encontrada' });
    } else {
      res.json(venta);
    }
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener venta', error });
  }
};

// POST create new venta
const createVenta: RequestHandler = async (req, res) => {
  try {
    const venta = await Venta.create(req.body);
    res.status(201).json(venta);
  } catch (error) {
    res.status(400).json({ message: 'Error al crear venta', error });
  }
};

// PUT update venta
const updateVenta: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const venta = await Venta.findByPk(req.params.id);
    if (!venta) {
      res.status(404).json({ message: 'Venta no encontrada' });
    } else {
      await venta.update(req.body);
      res.json(venta);
    }
  } catch (error) {
    res.status(400).json({ message: 'Error al actualizar venta', error });
  }
};

// DELETE venta
const deleteVenta: RequestHandler<{ id: string }> = async (req, res) => {
  try {
    const venta = await Venta.findByPk(req.params.id);
    if (!venta) {
      res.status(404).json({ message: 'Venta no encontrada' });
    } else {
      await venta.destroy();
      res.status(204).send();
    }
  } catch (error) {
    res.status(500).json({ message: 'Error al eliminar venta', error });
  }
};

// Route definitions
router.get('/', getAllVentas);
router.get('/:id', getVentaById);
router.post('/', createVenta);
router.put('/:id', updateVenta);
router.delete('/:id', deleteVenta);

export default router;import { Router, RequestHandler } from 'express';
import { RolUsuarioController } from '../../controllers/catalogs/rol-usuario.controller';
import { verificarToken, verificarRol } from '../../middlewares/auth.middleware';
import { RolUsuario } from '../../types';

const router = Router();
const controller = new RolUsuarioController();

// Aplicar middleware de autenticaci√≥n a todas las rutas
router.use(verificarToken as RequestHandler);

// Obtener todos los roles de usuario
router.get('/', (async (req, res) => {
    await controller.getAll(req, res);
}) as RequestHandler);

// Obtener un rol de usuario por ID
router.get('/:id', (async (req, res) => {
    await controller.getById(req, res);
}) as RequestHandler);

// Crear un nuevo rol de usuario (solo administradores)
router.post('/', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.create(req, res);
    }) as RequestHandler
);

// Actualizar un rol de usuario (solo administradores)
router.put('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.update(req, res);
    }) as RequestHandler
);

// Eliminar un rol de usuario (solo administradores)
router.delete('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.delete(req, res);
    }) as RequestHandler
);

export default router;import { Router, RequestHandler } from 'express';
import { TipoIdentificacionController } from '../../controllers/catalogs/tipo-identificacion.controller';
import { verificarToken, verificarRol } from '../../middlewares/auth.middleware';
import { RolUsuario } from '../../types';

const router = Router();
const controller = new TipoIdentificacionController();

// Aplicar middleware de autenticaci√≥n a todas las rutas
router.use(verificarToken as RequestHandler);

// Obtener todos los tipos de identificaci√≥n
router.get('/', (async (req, res) => {
    await controller.getAll(req, res);
}) as RequestHandler);

// Obtener un tipo de identificaci√≥n por ID
router.get('/:id', (async (req, res) => {
    await controller.getById(req, res);
}) as RequestHandler);

// Crear un nuevo tipo de identificaci√≥n (solo administradores)
router.post('/', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.create(req, res);
    }) as RequestHandler
);

// Actualizar un tipo de identificaci√≥n (solo administradores)
router.put('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.update(req, res);
    }) as RequestHandler
);

// Eliminar un tipo de identificaci√≥n (solo administradores)
router.delete('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.delete(req, res);
    }) as RequestHandler
);

export default router;import { Router, RequestHandler } from 'express';
import { TipoTransaccionController } from '../../controllers/catalogs/tipo-transaccion.controller';
import { verificarToken, verificarRol } from '../../middlewares/auth.middleware';
import { RolUsuario } from '../../types';

const router = Router();
const controller = new TipoTransaccionController();

// Aplicar middleware de autenticaci√≥n a todas las rutas
router.use(verificarToken as RequestHandler);

// Obtener todos los tipos de transacci√≥n
router.get('/', (async (req, res) => {
    await controller.getAll(req, res);
}) as RequestHandler);

// Obtener un tipo de transacci√≥n por ID
router.get('/:id', (async (req, res) => {
    await controller.getById(req, res);
}) as RequestHandler);

// Crear un nuevo tipo de transacci√≥n (solo administradores)
router.post('/', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.create(req, res);
    }) as RequestHandler
);

// Actualizar un tipo de transacci√≥n (solo administradores)
router.put('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.update(req, res);
    }) as RequestHandler
);

// Eliminar un tipo de transacci√≥n (solo administradores)
router.delete('/:id', 
    verificarRol([RolUsuario.Administrador]) as RequestHandler,
    (async (req, res) => {
        await controller.delete(req, res);
    }) as RequestHandler
);

export default router;import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Vehiculo } from './vehiculo.model';

// Tipos de ajustes comunes
export type TipoAjuste = 'Depreciaci√≥n' | 'Reparaci√≥n' | 'Mejora' | 'Da√±o' | 'Otro';

@Table({
    tableName: 'ajustes_valor_vehiculo',
    timestamps: false
})
export class AjusteValorVehiculo extends Model {
    @Column({
        type: DataType.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        field: 'id_ajuste'
    })
    id_ajuste!: number;

    @ForeignKey(() => Vehiculo)
    @Column({
        type: DataType.INTEGER,
        allowNull: false,
        field: 'id_vehiculo',
        references: {
            model: 'vehiculos',
            key: 'id_vehiculo'
        }
    })
    id_vehiculo!: number;

    @Column({
        type: DataType.STRING(100),
        allowNull: false,
        field: 'concepto',
        validate: {
            notEmpty: true,
            isIn: [['Depreciaci√≥n', 'Reparaci√≥n', 'Mejora', 'Da√±o', 'Otro']]
        }
    })
    concepto!: TipoAjuste;

    @Column({
        type: DataType.DECIMAL(10, 2),
        allowNull: false,
        field: 'monto_ajuste',
        validate: {
            notNull: true
        }
    })
    monto_ajuste!: number;

    @Column({
        type: DataType.TEXT,
        allowNull: true,
        field: 'detalle'
    })
    detalle?: string;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW,
        field: 'fecha'
    })
    fecha!: Date;

    // Relaciones
    @BelongsTo(() => Vehiculo, {
        foreignKey: 'id_vehiculo',
        as: 'vehiculoAjuste'
    })
    vehiculo!: Vehiculo;

    // M√©todos √∫tiles
    esPositivo(): boolean {
        return this.monto_ajuste > 0;
    }

    esNegativo(): boolean {
        return this.monto_ajuste < 0;
    }

    // M√©todo para obtener el impacto porcentual sobre el valor original
    async getPorcentajeImpacto(): Promise<number> {
        const vehiculo = await this.$get('vehiculo');
        if (!vehiculo) return 0;
        return (this.monto_ajuste / vehiculo.precio) * 100;
    }

    // M√©todo para obtener el resumen del ajuste
    async getResumen(): Promise<{
        tipo: TipoAjuste;
        monto: number;
        impactoPorcentual: number;
        fecha: Date;
        detalle?: string;
    }> {
        const impactoPorcentual = await this.getPorcentajeImpacto();
        
        return {
            tipo: this.concepto,
            monto: this.monto_ajuste,
            impactoPorcentual,
            fecha: this.fecha,
            detalle: this.detalle
        };
    }

    // M√©todo est√°tico para obtener el historial de ajustes de un veh√≠culo
    static async getHistorialAjustes(idVehiculo: number): Promise<{
        ajustes: AjusteValorVehiculo[];
        totalAjustes: number;
        ajustesPositivos: number;
        ajustesNegativos: number;
    }> {
        const ajustes = await this.findAll({
            where: { id_vehiculo: idVehiculo },
            order: [['fecha', 'DESC']]
        });

        const totalAjustes = ajustes.reduce((sum, ajuste) => sum + ajuste.monto_ajuste, 0);
        const ajustesPositivos = ajustes
            .filter(ajuste => ajuste.monto_ajuste > 0)
            .reduce((sum, ajuste) => sum + ajuste.monto_ajuste, 0);
        const ajustesNegativos = ajustes
            .filter(ajuste => ajuste.monto_ajuste < 0)
            .reduce((sum, ajuste) => sum + ajuste.monto_ajuste, 0);

        return {
            ajustes,
            totalAjustes,
            ajustesPositivos,
            ajustesNegativos
        };
    }

    // M√©todo est√°tico para obtener estad√≠sticas de ajustes por tipo
    static async getEstadisticasPorTipo(idVehiculo: number): Promise<{
        [key in TipoAjuste]?: {
            cantidad: number;
            montoTotal: number;
            promedio: number;
        };
    }> {
        const ajustes = await this.findAll({
            where: { id_vehiculo: idVehiculo }
        });

        const estadisticas: any = {};

        ajustes.forEach(ajuste => {
            if (!estadisticas[ajuste.concepto]) {
                estadisticas[ajuste.concepto] = {
                    cantidad: 0,
                    montoTotal: 0,
                    promedio: 0
                };
            }

            estadisticas[ajuste.concepto].cantidad++;
            estadisticas[ajuste.concepto].montoTotal += ajuste.monto_ajuste;
        });

        // Calcular promedios
        Object.keys(estadisticas).forEach(tipo => {
            estadisticas[tipo].promedio = estadisticas[tipo].montoTotal / estadisticas[tipo].cantidad;
        });

        return estadisticas;
    }
}

export default AjusteValorVehiculo;import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Cita } from './cita.model';
import { Usuario } from './usuario.model';

@Table({
  tableName: 'citas_empleados',
  timestamps: false
})
export class CitaEmpleado extends Model {
  @ForeignKey(() => Cita)
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    field: 'id_cita',
    references: {
      model: 'citas',
      key: 'id_cita'
    }
  })
  idCita!: number;

  @ForeignKey(() => Usuario)
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    field: 'id_empleado',
    references: {
      model: 'usuarios',
      key: 'id_usuario'
    }
  })
  idEmpleado!: number;

  @Column({
    type: DataType.DATE,
    allowNull: false,
    defaultValue: DataType.NOW,
    field: 'fecha_asignacion'
  })
  fechaAsignacion!: Date;

  // Relaciones
  @BelongsTo(() => Cita, {
    foreignKey: 'id_cita',
    as: 'cita'
  })
  cita?: Cita;

  @BelongsTo(() => Usuario, {
    foreignKey: 'id_empleado',
    as: 'empleado'
  })
  empleado?: Usuario;

  // M√©todos √∫tiles
  static async asignarEmpleadosACita(idCita: number, empleadosIds: number[]): Promise<CitaEmpleado[]> {
    // Eliminar asignaciones existentes
    await this.destroy({
      where: { id_cita: idCita }
    });

    // Crear nuevas asignaciones
    const asignaciones = await Promise.all(
      empleadosIds.map(idEmpleado =>
        this.create({
          idCita,
          idEmpleado,
          fechaAsignacion: new Date()
        })
      )
    );

    return asignaciones;
  }

  static async getEmpleadosPorCita(idCita: number): Promise<Usuario[]> {
    const asignaciones = await this.findAll({
      where: { id_cita: idCita },
      include: [{
        model: Usuario,
        as: 'empleado'
      }]
    });

    return asignaciones.map(asignacion => asignacion.empleado!);
  }

  static async getCitasPorEmpleado(idEmpleado: number, fecha?: Date): Promise<Cita[]> {
    const where: any = { id_empleado: idEmpleado };
    
    if (fecha) {
      where['$cita.fecha$'] = fecha;
    }

    const asignaciones = await this.findAll({
      where,
      include: [{
        model: Cita,
        as: 'cita',
        required: true
      }]
    });

    return asignaciones.map(asignacion => asignacion.cita!);
  }

  // M√©todo para verificar si un empleado est√° disponible en una fecha y hora espec√≠fica
  static async verificarDisponibilidadEmpleado(idEmpleado: number, fecha: Date, hora: string): Promise<boolean> {
    const citasEmpleado = await this.findAll({
      include: [{
        model: Cita,
        as: 'cita',
        where: {
          fecha,
          hora
        }
      }],
      where: {
        id_empleado: idEmpleado
      }
    });

    return citasEmpleado.length === 0;
  }

  // M√©todo para obtener el historial de asignaciones de un empleado
  static async getHistorialAsignaciones(idEmpleado: number, fechaInicio: Date, fechaFin: Date): Promise<{
    totalCitas: number;
    citasPorTipo: { [key: string]: number };
    citasPorDia: { [key: string]: number };
  }> {
    const asignaciones = await this.findAll({
      include: [{
        model: Cita,
        as: 'cita',
        where: {
          fecha: {
            [Op.between]: [fechaInicio, fechaFin]
          }
        }
      }],
      where: {
        id_empleado: idEmpleado
      }
    });

    const resumen = {
      totalCitas: asignaciones.length,
      citasPorTipo: {} as { [key: string]: number },
      citasPorDia: {} as { [key: string]: number }
    };

    asignaciones.forEach(asignacion => {
      const cita = asignacion.cita!;
      // Contar por tipo
      resumen.citasPorTipo[cita.tipoCita] = (resumen.citasPorTipo[cita.tipoCita] || 0) + 1;
      
      // Contar por d√≠a
      const fecha = cita.fecha.toISOString().split('T')[0];
      resumen.citasPorDia[fecha] = (resumen.citasPorDia[fecha] || 0) + 1;
    });

    return resumen;
  }
}

export default CitaEmpleado;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, BelongsToMany } from 'sequelize-typescript';
import { Usuario } from './usuario.model';
import { Contacto } from './contacto.model';
import { Vehiculo } from './vehiculo.model';
import { CitaEmpleado } from './cita-empleado.model';
import { Op } from 'sequelize';

// Tipos de cita
export type TipoCita = 'Venta' | 'Prueba de Manejo' | 'Revisi√≥n' | 'Entrega' | 'Seguimiento';

@Table({
  tableName: 'citas',
  timestamps: false
})
export class Cita extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_cita'
  })
  id!: number;

  @ForeignKey(() => Usuario)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_empleado_creador',
    references: {
      model: 'usuarios',
      key: 'id_usuario'
    }
  })
  idEmpleadoCreador!: number;

  @ForeignKey(() => Contacto)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_contacto',
    references: {
      model: 'contactos',
      key: 'id_contacto'
    }
  })
  idContacto!: number;

  @ForeignKey(() => Vehiculo)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_vehiculo',
    references: {
      model: 'vehiculos',
      key: 'id_vehiculo'
    }
  })
  idVehiculo?: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'tipo_cita',
    validate: {
      isIn: [['Venta', 'Prueba de Manejo', 'Revisi√≥n', 'Entrega', 'Seguimiento']]
    }
  })
  tipoCita!: TipoCita;

  @Column({
    type: DataType.DATE,
    allowNull: false
  })
  fecha!: Date;

  @Column({
    type: DataType.TIME,
    allowNull: false
  })
  hora!: string;

  @Column({
    type: DataType.STRING(200),
    allowNull: false
  })
  lugar!: string;

  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    defaultValue: 0,
    validate: {
      max: 3
    }
  })
  reagendaciones!: number;

  // Relaciones
  @BelongsTo(() => Usuario, {
    foreignKey: 'id_empleado_creador',
    as: 'creador'
  })
  creador!: Usuario;

  @BelongsTo(() => Contacto, {
    foreignKey: 'id_contacto',
    as: 'contactoCita'
  })
  contacto!: Contacto;

  @BelongsTo(() => Vehiculo, {
    foreignKey: 'id_vehiculo',
    as: 'vehiculoCita'
  })
  vehiculo?: Vehiculo;

  @BelongsToMany(() => Usuario, {
    through: () => CitaEmpleado,
    foreignKey: 'id_cita',
    otherKey: 'id_empleado',
    as: 'usuariosCita'
  })
  empleados?: Usuario[];

  // M√©todos √∫tiles
  async reagendar(nuevaFecha: Date, nuevaHora: string): Promise<void> {
    if (this.reagendaciones >= 3) {
      throw new Error('No se puede reagendar la cita m√°s de 3 veces');
    }

    this.fecha = nuevaFecha;
    this.hora = nuevaHora;
    this.reagendaciones += 1;
    await this.save();
  }

  async asignarEmpleados(empleadosIds: number[]): Promise<void> {
    await CitaEmpleado.destroy({
      where: { id_cita: this.id }
    });

    await Promise.all(
      empleadosIds.map(idEmpleado =>
        CitaEmpleado.create({
          id_cita: this.id,
          id_empleado: idEmpleado,
          fecha_asignacion: new Date()
        })
      )
    );
  }

  static async getCitasDelDia(fecha: Date = new Date()): Promise<Cita[]> {
    const inicio = new Date(fecha.setHours(0, 0, 0, 0));
    const fin = new Date(fecha.setHours(23, 59, 59, 999));

    return await this.findAll({
      where: {
        fecha: {
          [Op.between]: [inicio, fin]
        }
      },
      include: [
        {
          model: Contacto,
          as: 'contactoCita'
        },
        {
          model: Vehiculo,
          as: 'vehiculoCita'
        },
        {
          model: Usuario,
          as: 'usuariosCita'
        }
      ],
      order: [['hora', 'ASC']]
    });
  }

  static async getCitasPorEmpleado(idEmpleado: number, inicio?: Date, fin?: Date): Promise<Cita[]> {
    const where: any = {
      '$usuariosCita.id$': idEmpleado
    };

    if (inicio && fin) {
      where.fecha = {
        [Op.between]: [inicio, fin]
      };
    }

    return await this.findAll({
      where,
      include: [
        {
          model: Contacto,
          as: 'contactoCita'
        },
        {
          model: Vehiculo,
          as: 'vehiculoCita'
        },
        {
          model: Usuario,
          as: 'usuariosCita'
        }
      ],
      order: [['fecha', 'ASC'], ['hora', 'ASC']]
    });
  }

  // M√©todo para verificar disponibilidad
  static async verificarDisponibilidad(fecha: Date, hora: string): Promise<boolean> {
    const citasExistentes = await this.count({
      where: {
        fecha,
        hora
      }
    });

    return citasExistentes === 0;
  }

  // M√©todo para obtener el resumen de citas
  static async getResumenCitas(inicio: Date, fin: Date): Promise<{
    total: number;
    porTipo: { [key in TipoCita]?: number };
    reagendadas: number;
  }> {
    const citas = await this.findAll({
      where: {
        fecha: {
          [Op.between]: [inicio, fin]
        }
      }
    });

    const resumen = {
      total: citas.length,
      porTipo: {} as { [key in TipoCita]?: number },
      reagendadas: 0
    };

    citas.forEach(cita => {
      resumen.porTipo[cita.tipoCita] = (resumen.porTipo[cita.tipoCita] || 0) + 1;
      if (cita.reagendaciones > 0) {
        resumen.reagendadas++;
      }
    });

    return resumen;
  }
}

export default Cita;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasMany, BeforeValidate } from 'sequelize-typescript';
import { TipoIdentificacion } from './catalogs/tipo-identificacion.model';
import { Credito } from './credito.model';
import { Transaccion } from './transaccion.model';
import { Contacto } from './contacto.model';
import { Documento } from './documento.model';

@Table({
  tableName: 'clientes',
  timestamps: false
})
export class Cliente extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_cliente'
  })
  id!: number;

  @Column({
    type: DataType.STRING(100),
    allowNull: false
  })
  nombre!: string;

  @Column({
    type: DataType.STRING(18),
    allowNull: true,
    validate: {
      isValidCurp(value: string) {
        if (this.tipoPersona === 'F√≠sica' && !value) {
          throw new Error('El CURP es obligatorio para personas f√≠sicas');
        }
      }
    }
  })
  curp!: string;

  @ForeignKey(() => TipoIdentificacion)
  @Column({
    type: DataType.INTEGER,
    field: 'id_tipo_identificacion',
    references: {
      model: 'tipos_identificacion',
      key: 'id_tipo_identificacion'
    }
  })
  idTipoIdentificacion?: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'num_identificacion'
  })
  numIdentificacion!: string;

  @Column({
    type: DataType.DATE,
    allowNull: false,
    field: 'fecha_nacimiento'
  })
  fechaNacimiento!: Date;

  @Column({
    type: DataType.STRING(20),
    allowNull: false
  })
  telefono!: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: false
  })
  correo!: string;

  @Column({
    type: DataType.STRING(200),
    allowNull: false
  })
  domicilio!: string;

  @Column({
    type: DataType.STRING(10),
    allowNull: false,
    defaultValue: 'F√≠sica',
    field: 'tipo_persona',
    validate: {
      isIn: [['F√≠sica', 'Moral']]
    }
  })
  tipoPersona!: 'F√≠sica' | 'Moral';

  @Column({
    type: DataType.STRING(200),
    allowNull: true,
    field: 'razon_social',
    validate: {
      isValidRazonSocial(value: string) {
        if (this.tipoPersona === 'Moral' && !value) {
          throw new Error('La raz√≥n social es obligatoria para personas morales');
        }
      }
    }
  })
  razonSocial?: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'representante_legal'
  })
  representanteLegal?: string;

  @Column({
    type: DataType.STRING(13),
    allowNull: true,
    validate: {
      isValidRfc(value: string) {
        if (this.tipoPersona === 'Moral' && !value) {
          throw new Error('El RFC es obligatorio para personas morales');
        }
        if (value && value.trim() !== '') {
          if (value.length !== 12 && value.length !== 13) {
            throw new Error('El RFC debe tener 12 o 13 caracteres');
          }
          if (!/^[A-Z&√ë]{3,4}[0-9]{6}[A-Z0-9]{3}$/.test(value)) {
            throw new Error('El formato del RFC no es v√°lido');
          }
        }
      }
    }
  })
  rfc?: string;

  @Column({
    type: DataType.DATE,
    allowNull: true,
    field: 'fecha_constitucion',
    validate: {
      isValidFechaConstitucion(value: Date) {
        if (this.tipoPersona === 'Moral' && !value) {
          throw new Error('La fecha de constituci√≥n es obligatoria para personas morales');
        }
      }
    }
  })
  fechaConstitucion?: Date;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'regimen_fiscal',
    validate: {
      isValidRegimenFiscal(value: string) {
        if (this.tipoPersona === 'Moral' && !value) {
          throw new Error('El r√©gimen fiscal es obligatorio para personas morales');
        }
      }
    }
  })
  regimenFiscal?: string;

  @Column({
    type: DataType.STRING(255),
    allowNull: true,
    field: 'acta_constitutiva_url'
  })
  actaConstitutivaUrl?: string;

  @Column({
    type: DataType.STRING(255),
    allowNull: true,
    field: 'poder_notarial_url'
  })
  poderNotarialUrl?: string;

  @Column({
    type: DataType.STRING(255),
    allowNull: true,
    field: 'comprobante_domicilio_url'
  })
  comprobanteDomicilioUrl?: string;

  // Relaciones
  @BelongsTo(() => TipoIdentificacion, {
    foreignKey: 'id_tipo_identificacion'
  })
  tipoIdentificacion?: TipoIdentificacion;

  @HasMany(() => Credito, {
    foreignKey: 'id_cliente'
  })
  creditos?: Credito[];

  @HasMany(() => Transaccion, {
    foreignKey: 'id_cliente'
  })
  transacciones?: Transaccion[];

  @HasMany(() => Contacto, {
    foreignKey: 'id_cliente'
  })
  contactos?: Contacto[];

  @HasMany(() => Documento, {
    foreignKey: 'id_cliente'
  })
  documentos?: Documento[];

  @BeforeValidate
  static async validatePersonaFields(instance: Cliente) {
    if (instance.tipoPersona === 'Moral') {
      if (!instance.razonSocial) {
        throw new Error('La raz√≥n social es obligatoria para personas morales');
      }
      if (!instance.rfc) {
        throw new Error('El RFC es obligatorio para personas morales');
      }
      if (!instance.fechaConstitucion) {
        throw new Error('La fecha de constituci√≥n es obligatoria para personas morales');
      }
      if (!instance.regimenFiscal) {
        throw new Error('El r√©gimen fiscal es obligatorio para personas morales');
      }
    } else if (instance.tipoPersona === 'F√≠sica') {
      if (!instance.curp) {
        throw new Error('El CURP es obligatorio para personas f√≠sicas');
      }
    }
  }
}

export default Cliente;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { Vehiculo } from './vehiculo.model';
import { Contacto } from './contacto.model';
import { GastoConsignacion } from './gasto-consignacion.model';

// Tipos de origen del veh√≠culo
export type OrigenVehiculoTipo = 'Particular' | 'Agencia' | 'Lote' | 'Otro';

// Interfaces para los tipos de datos
interface GastoPorTipo {
  [concepto: string]: number;
}

interface DistribucionGastos {
  totalGastos: number;
  gastosPorTipo: GastoPorTipo;
  porcentajeConsignatario: number;
  porcentajeAgencia: number;
}

@Table({
  tableName: 'consignaciones',
  timestamps: false
})
export class Consignacion extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_consignacion'
  })
  id!: number;

  @ForeignKey(() => Vehiculo)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_vehiculo',
    references: {
      model: 'vehiculos',
      key: 'id_vehiculo'
    }
  })
  idVehiculo!: number;

  @Column({
    type: DataType.STRING(100),
    allowNull: false,
    field: 'nombre_consignatario'
  })
  nombreConsignatario!: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: false,
    field: 'apellidos_consignatario'
  })
  apellidosConsignatario!: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: false,
    field: 'correo_consignatario'
  })
  correoConsignatario!: string;

  @Column({
    type: DataType.STRING(20),
    allowNull: false,
    field: 'telefono_consignatario'
  })
  telefonoConsignatario!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'origen_vehiculo_tipo',
    validate: {
      isIn: [['Particular', 'Agencia', 'Lote', 'Otro']]
    }
  })
  origenVehiculoTipo?: OrigenVehiculoTipo;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'origen_vehiculo_nombre'
  })
  origenVehiculoNombre?: string;

  // Relaciones
  @BelongsTo(() => Vehiculo, {
    foreignKey: 'id_vehiculo',
    as: 'vehiculoConsignado'
  })
  vehiculo?: Vehiculo;

  @HasMany(() => Contacto, {
    foreignKey: 'id_consignacion',
    as: 'contactosConsignacion'
  })
  contactos?: Contacto[];

  @HasMany(() => GastoConsignacion, {
    foreignKey: 'id_consignacion',
    as: 'gastosConsignacion'
  })
  gastos?: GastoConsignacion[];

  // M√©todos √∫tiles
  getNombreCompleto(): string {
    return `${this.nombreConsignatario} ${this.apellidosConsignatario}`;
  }

  async getTotalGastos(): Promise<number> {
    const gastos = await GastoConsignacion.findAll({
      where: { id_consignacion: this.id }
    });
    return gastos.reduce((total, gasto) => total + gasto.costo_total, 0);
  }

  async getGastosPorTipo(): Promise<GastoPorTipo> {
    const gastos = await GastoConsignacion.findAll({
      where: { id_consignacion: this.id }
    });
    return gastos.reduce((acc: GastoPorTipo, gasto) => {
      acc[gasto.concepto] = (acc[gasto.concepto] || 0) + gasto.costo_total;
      return acc;
    }, {});
  }

  async getDistribucionGastos(): Promise<DistribucionGastos> {
    const gastos = await GastoConsignacion.findAll({
      where: { id_consignacion: this.id }
    });

    const totalGastos = gastos.reduce((total, gasto) => total + gasto.costo_total, 0);
    const gastosPorTipo = gastos.reduce((acc: GastoPorTipo, gasto) => {
      acc[gasto.concepto] = (acc[gasto.concepto] || 0) + gasto.costo_total;
      return acc;
    }, {});

    // Calcular porcentajes promedio
    const porcentajes = gastos.reduce(
      (acc, gasto) => {
        acc.consignatario += gasto.porcentaje_consignatario;
        acc.agencia += gasto.porcentaje_agencia;
        return acc;
      },
      { consignatario: 0, agencia: 0 }
    );

    const totalGastosCount = gastos.length || 1;
    return {
      totalGastos,
      gastosPorTipo,
      porcentajeConsignatario: porcentajes.consignatario / totalGastosCount,
      porcentajeAgencia: porcentajes.agencia / totalGastosCount
    };
  }
}

export default Consignacion;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Cliente } from './cliente.model';
import { Consignacion } from './consignacion.model';
import { Cita } from './cita.model';

// Tipos de contacto
export type TipoContacto = 'Cliente' | 'Consignatario' | 'Referencia' | 'Familiar' | 'Otro';

@Table({
  tableName: 'contactos',
  timestamps: false
})
export class Contacto extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_contacto'
  })
  id!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'tipo_contacto',
    validate: {
      isIn: [['Cliente', 'Consignatario', 'Referencia', 'Familiar', 'Otro']]
    }
  })
  tipoContacto!: TipoContacto;

  @Column({
    type: DataType.STRING(100),
    allowNull: false
  })
  nombre!: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: false
  })
  apellidos!: string;

  @Column({
    type: DataType.STRING(20),
    allowNull: false
  })
  telefono!: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: false
  })
  correo!: string;

  @ForeignKey(() => Cliente)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_cliente',
    references: {
      model: 'clientes',
      key: 'id_cliente'
    }
  })
  idCliente?: number;

  @ForeignKey(() => Consignacion)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_consignacion',
    references: {
      model: 'consignaciones',
      key: 'id_consignacion'
    }
  })
  idConsignacion?: number;

  // Relaciones
  @BelongsTo(() => Cliente, {
    foreignKey: 'id_cliente',
    as: 'clienteContacto'
  })
  cliente?: Cliente;

  @BelongsTo(() => Consignacion, {
    foreignKey: 'id_consignacion',
    as: 'consignacionContacto'
  })
  consignacion?: Consignacion;

  @HasMany(() => Cita, {
    foreignKey: 'id_contacto',
    as: 'citasContacto'
  })
  citas?: Cita[];

  // M√©todos √∫tiles
  getNombreCompleto(): string {
    return `${this.nombre} ${this.apellidos}`;
  }

  async getCitasPendientes(): Promise<Cita[]> {
    const ahora = new Date();
    return await Cita.findAll({
      where: {
        id_contacto: this.id,
        fecha: {
          [Op.gte]: ahora
        }
      },
      order: [['fecha', 'ASC']]
    });
  }

  async getCitasHistoricas(): Promise<Cita[]> {
    const ahora = new Date();
    return await Cita.findAll({
      where: {
        id_contacto: this.id,
        fecha: {
          [Op.lt]: ahora
        }
      },
      order: [['fecha', 'DESC']]
    });
  }

  async getUltimaCita(): Promise<Cita | null> {
    return await Cita.findOne({
      where: {
        id_contacto: this.id
      },
      order: [['fecha', 'DESC']]
    });
  }

  async getProximaCita(): Promise<Cita | null> {
    const ahora = new Date();
    return await Cita.findOne({
      where: {
        id_contacto: this.id,
        fecha: {
          [Op.gte]: ahora
        }
      },
      order: [['fecha', 'ASC']]
    });
  }

  // M√©todo para validar si el contacto est√° relacionado con un cliente o una consignaci√≥n
  validarRelacion(): boolean {
    if (!this.idCliente && !this.idConsignacion) {
      throw new Error('El contacto debe estar relacionado con un cliente o una consignaci√≥n');
    }
    if (this.idCliente && this.idConsignacion) {
      throw new Error('El contacto no puede estar relacionado con un cliente y una consignaci√≥n al mismo tiempo');
    }
    return true;
  }

  // M√©todo para obtener todas las citas en un rango de fechas
  async getCitasEnRango(fechaInicio: Date, fechaFin: Date): Promise<Cita[]> {
    return await Cita.findAll({
      where: {
        id_contacto: this.id,
        fecha: {
          [Op.between]: [fechaInicio, fechaFin]
        }
      },
      order: [['fecha', 'ASC']]
    });
  }

  // M√©todo para obtener el resumen de citas
  async getResumenCitas(): Promise<{
    totalCitas: number;
    citasPendientes: number;
    citasHistoricas: number;
    proximaCita: Cita | null;
    ultimaCita: Cita | null;
  }> {
    const [citasPendientes, citasHistoricas, proximaCita, ultimaCita] = await Promise.all([
      this.getCitasPendientes(),
      this.getCitasHistoricas(),
      this.getProximaCita(),
      this.getUltimaCita()
    ]);

    return {
      totalCitas: citasPendientes.length + citasHistoricas.length,
      citasPendientes: citasPendientes.length,
      citasHistoricas: citasHistoricas.length,
      proximaCita,
      ultimaCita
    };
  }
}

export default Contacto;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { Cliente } from './cliente.model';
import { Transaccion } from './transaccion.model';

@Table({
  tableName: 'creditos',
  timestamps: false
})
export class Credito extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_credito'
  })
  id!: number;

  @ForeignKey(() => Cliente)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_cliente',
    references: {
      model: 'clientes',
      key: 'id_cliente'
    }
  })
  idCliente!: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false
  })
  cantidad!: number;

  @Column({
    type: DataType.STRING(200),
    allowNull: true
  })
  comentarios?: string;

  // Relaciones
  @BelongsTo(() => Cliente, {
    foreignKey: 'id_cliente'
  })
  cliente?: Cliente;

  @HasMany(() => Transaccion, {
    foreignKey: 'id_credito'
  })
  transacciones?: Transaccion[];
}

export default Credito;// documento.model.ts

import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Transaccion } from './transaccion.model';
import { Cliente } from './cliente.model';
import { Vehiculo } from './vehiculo.model';
import { Usuario } from './usuario.model';

// Estados de documento
export type DocumentoEstado = 'pendiente' | 'aprobado' | 'rechazado';

// Tipos de documento
export type TipoDocumento = 
  'Identificaci√≥n' | 
  'Comprobante de Domicilio' | 
  'Factura' | 
  'Contrato' | 
  'Carta Responsiva' | 
  'Poder Notarial' |
  'Acta Constitutiva' |
  'RFC' |
  'CURP' |
  'Comprobante de Ingresos' |
  'Estado de Cuenta' |
  'Otro';

// Permisos de acceso
export type PermisosAcceso = 'p√∫blico' | 'privado' | 'restringido';

// Extensiones permitidas
export type ExtensionArchivo = '.pdf' | '.jpg' | '.png' | '.xml';

// Tipo para la configuraci√≥n de validaci√≥n
type ValidacionDocumento = {
  extensionesPermitidas: ExtensionArchivo[];
  tama√±oMaximoMB: number;
  vigenciaRequerida?: boolean;
  antiguedadMaximaMeses?: number;
  requiereVerificacion?: boolean;
  requiereFirma?: boolean;
};

// Constantes para documentos requeridos por tipo de transacci√≥n
export const DOCUMENTOS_REQUERIDOS = {
  VENTA: ['Identificaci√≥n', 'Comprobante de Domicilio', 'Factura', 'Contrato'],
  CREDITO: ['Identificaci√≥n', 'Comprobante de Domicilio', 'Comprobante de Ingresos', 'Estado de Cuenta'],
  CONSIGNACION: ['Identificaci√≥n', 'Comprobante de Domicilio', 'Carta Responsiva', 'Contrato'],
  PERSONA_MORAL: ['Acta Constitutiva', 'Poder Notarial', 'RFC', 'Comprobante de Domicilio']
} as const;

// Configuraci√≥n de validaci√≥n por tipo de documento
export const VALIDACION_DOCUMENTOS: Record<TipoDocumento, ValidacionDocumento> = {
  'Identificaci√≥n': {
    extensionesPermitidas: ['.pdf', '.jpg', '.png'],
    tama√±oMaximoMB: 5,
    vigenciaRequerida: true,
    antiguedadMaximaMeses: 60,
    requiereVerificacion: true
  },
  'Comprobante de Domicilio': {
    extensionesPermitidas: ['.pdf', '.jpg', '.png'],
    tama√±oMaximoMB: 5,
    vigenciaRequerida: true,
    antiguedadMaximaMeses: 3
  },
  'Factura': {
    extensionesPermitidas: ['.pdf', '.xml'],
    tama√±oMaximoMB: 10,
    requiereVerificacion: true
  },
  'Contrato': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 10,
    requiereFirma: true
  },
  'Carta Responsiva': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 5,
    requiereFirma: true
  },
  'Poder Notarial': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 10,
    requiereVerificacion: true
  },
  'Acta Constitutiva': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 10,
    requiereVerificacion: true
  },
  'RFC': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 5,
    requiereVerificacion: true
  },
  'CURP': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 2,
    requiereVerificacion: true
  },
  'Comprobante de Ingresos': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 5,
    vigenciaRequerida: true,
    antiguedadMaximaMeses: 3
  },
  'Estado de Cuenta': {
    extensionesPermitidas: ['.pdf'],
    tama√±oMaximoMB: 10,
    vigenciaRequerida: true,
    antiguedadMaximaMeses: 3
  },
  'Otro': {
    extensionesPermitidas: ['.pdf', '.jpg', '.png'],
    tama√±oMaximoMB: 10
  }
};

@Table({
  tableName: 'documentos',
  timestamps: false
})
export class Documento extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_documento'
  })
  id!: number;

  @ForeignKey(() => Usuario)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_empleado',
    references: {
      model: 'usuarios',
      key: 'id_usuario'
    }
  })
  idEmpleado?: number;

  @ForeignKey(() => Cliente)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_cliente',
    references: {
      model: 'clientes',
      key: 'id_cliente'
    }
  })
  idCliente?: number;

  @ForeignKey(() => Vehiculo)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_vehiculo',
    references: {
      model: 'vehiculos',
      key: 'id_vehiculo'
    }
  })
  idVehiculo?: number;

  @ForeignKey(() => Transaccion)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_transaccion',
    references: {
      model: 'transacciones',
      key: 'id_transaccion'
    }
  })
  idTransaccion?: number;

  @Column({
    type: DataType.DATE,
    allowNull: true,
    field: 'fecha_transaccion'
  })
  fechaTransaccion?: Date;

  @Column({
    type: DataType.STRING(255),
    allowNull: false,
    validate: {
      notEmpty: true
    }
  })
  url!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'tipo_documento',
    validate: {
      isIn: [Object.keys(VALIDACION_DOCUMENTOS)]
    }
  })
  tipoDocumento!: TipoDocumento;

  @Column({
    type: DataType.DATE,
    allowNull: false,
    defaultValue: DataType.NOW,
    field: 'fecha_subida'
  })
  fechaSubida!: Date;

  @Column({
    type: DataType.TEXT,
    allowNull: true
  })
  descripcion?: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'permisos_acceso',
    defaultValue: 'privado',
    validate: {
      isIn: [['p√∫blico', 'privado', 'restringido']]
    }
  })
  permisosAcceso?: PermisosAcceso;

  @Column({
    type: DataType.ENUM('pendiente', 'aprobado', 'rechazado'),
    allowNull: false,
    defaultValue: 'pendiente',
    field: 'estado'
  })
  estado!: DocumentoEstado;

  // Relaciones
  @BelongsTo(() => Usuario, { foreignKey: 'id_empleado', as: 'usuarioDocumento' })
  usuario?: Usuario;

  @BelongsTo(() => Cliente, { foreignKey: 'id_cliente', as: 'clienteDocumento' })
  cliente?: Cliente;

  @BelongsTo(() => Vehiculo, { foreignKey: 'id_vehiculo', as: 'vehiculoDocumento' })
  vehiculo?: Vehiculo;

  @BelongsTo(() => Transaccion, {
    foreignKey: 'id_transaccion',
    targetKey: 'id',
    as: 'transaccionDocumento',
    constraints: false
  })
  transaccion?: Transaccion;

  // M√©todos √∫tiles
  async getTransaccionCompleta() {
    if (!this.idTransaccion || !this.fechaTransaccion) {
      return null;
    }

    return await Transaccion.findOne({
      where: {
        id: this.idTransaccion,
        fecha: this.fechaTransaccion
      }
    });
  }

  // M√©todo para cambiar el estado del documento
  async cambiarEstado(nuevoEstado: DocumentoEstado, idUsuario: number, comentario?: string): Promise<void> {
    this.estado = nuevoEstado;
    this.idEmpleado = idUsuario;
    if (comentario) {
      this.descripcion = this.descripcion 
        ? `${this.descripcion}\n[${new Date().toISOString()}] ${comentario}`
        : `[${new Date().toISOString()}] ${comentario}`;
    }
    await this.save();
  }

  // M√©todo para verificar permisos de acceso
  async tieneAcceso(idUsuario: number): Promise<boolean> {
    if (this.permisosAcceso === 'p√∫blico') {
      return true;
    }

    if (this.permisosAcceso === 'privado') {
      return this.idEmpleado === idUsuario;
    }

    const usuario = await Usuario.findByPk(idUsuario);
    if (!usuario) return false;
    return [1, 2].includes(usuario.id_rol);
  }

  // M√©todo para validar el documento seg√∫n su tipo
  validarDocumento(): { valido: boolean; errores: string[] } {
    const errores: string[] = [];
    const validacion = VALIDACION_DOCUMENTOS[this.tipoDocumento];
    
    // Validar extensi√≥n
    const extension = this.url.substring(this.url.lastIndexOf('.')) as ExtensionArchivo;
    if (!validacion.extensionesPermitidas.includes(extension)) {
      errores.push(`Extensi√≥n no permitida. Permitidas: ${validacion.extensionesPermitidas.join(', ')}`);
    }

    // Validar vigencia si es requerida
    if (validacion.vigenciaRequerida && validacion.antiguedadMaximaMeses) {
      const fechaLimite = new Date();
      fechaLimite.setMonth(fechaLimite.getMonth() - validacion.antiguedadMaximaMeses);
      if (this.fechaSubida < fechaLimite) {
        errores.push(`Documento vencido. Antig√ºedad m√°xima: ${validacion.antiguedadMaximaMeses} meses`);
      }
    }

    return {
      valido: errores.length === 0,
      errores
    };
  }

  // M√©todo para obtener documentos por tipo y entidad
  static async getDocumentosPorTipoYEntidad(
    tipo: TipoDocumento,
    params: {
      idCliente?: number;
      idVehiculo?: number;
      idTransaccion?: number;
      fechaTransaccion?: Date;
    }
  ): Promise<Documento[]> {
    const where: any = { tipo_documento: tipo };

    if (params.idCliente) where.id_cliente = params.idCliente;
    if (params.idVehiculo) where.idVehiculo = params.idVehiculo;
    if (params.idTransaccion) {
      where.id_transaccion = params.idTransaccion;
      if (params.fechaTransaccion) where.fecha_transaccion = params.fechaTransaccion;
    }

    return await this.findAll({
      where,
      include: [
        { model: Usuario, as: 'usuarioDocumento' },
        { model: Cliente, as: 'clienteDocumento' },
        { model: Vehiculo, as: 'vehiculoDocumento' }
      ],
      order: [['fecha_subida', 'DESC']]
    });
  }

  // M√©todo para obtener documentos pendientes
  static async getDocumentosPendientes(diasAntiguedad: number = 30): Promise<Documento[]> {
    return await this.findAll({
      where: {
        estado: 'pendiente',
        fecha_subida: {
          [Op.gte]: new Date(new Date().setDate(new Date().getDate() - diasAntiguedad))
        }
      },
      include: [
        { model: Usuario, as: 'usuarioDocumento' },
        { model: Cliente, as: 'clienteDocumento' },
        { model: Vehiculo, as: 'vehiculoDocumento' }
      ],
      order: [['fecha_subida', 'ASC']]
    });
  }

  // M√©todo para verificar documentos requeridos
  static async verificarDocumentosRequeridos(
    tipoTransaccion: keyof typeof DOCUMENTOS_REQUERIDOS,
    idCliente: number
  ): Promise<{
    completo: boolean;
    documentosFaltantes: string[];
    documentosVencidos: string[];
  }> {
    const documentosRequeridos = DOCUMENTOS_REQUERIDOS[tipoTransaccion];
    const documentosExistentes = await this.findAll({
      where: {
        id_cliente: idCliente,
        tipo_documento: {
          [Op.in]: documentosRequeridos
        },
        estado: 'aprobado'
      }
    });

    const documentosFaltantes: string[] = [];
    const documentosVencidos: string[] = [];

    documentosRequeridos.forEach(tipoDoc => {
      const documento = documentosExistentes.find(d => d.tipoDocumento === tipoDoc);
      if (!documento) {
        documentosFaltantes.push(tipoDoc);
      } else {
        const validacion = documento.validarDocumento();
        if (!validacion.valido) {
          documentosVencidos.push(tipoDoc);
        }
      }
    });

    return {
      completo: documentosFaltantes.length === 0 && documentosVencidos.length === 0,
      documentosFaltantes,
      documentosVencidos
    };
  }
}

export default Documento;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasMany, BelongsToMany } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Usuario } from './usuario.model';
import { TipoIdentificacion } from './catalogs/tipo-identificacion.model';
import { Nomina } from './nomina.model';
import { Venta } from './venta.model';
import { VentaEmpleado } from './venta-empleado.model';
import { Cita } from './cita.model';
import { CitaEmpleado } from './cita-empleado.model';
import { Documento } from './documento.model';

// Estados del empleado
export type EstadoEmpleado = 'Activo' | 'Inactivo' | 'Vacaciones' | 'Incapacidad' | 'Baja';

// Tipos de documentos requeridos
export const DOCUMENTOS_REQUERIDOS = [
    'Identificaci√≥n',
    'CURP',
    'Comprobante de Domicilio',
    'Contrato Laboral',
    'Alta IMSS',
    'RFC'
] as const;

@Table({
    tableName: 'empleados',
    timestamps: false
})
export class Empleado extends Model {
    @Column({
        type: DataType.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        field: 'id_empleado'
    })
    id!: number;

    @ForeignKey(() => Usuario)
    @Column({
        type: DataType.INTEGER,
        allowNull: true,
        field: 'id_usuario',
        references: {
            model: 'usuarios',
            key: 'id_usuario'
        }
    })
    idUsuario?: number;

    @ForeignKey(() => TipoIdentificacion)
    @Column({
        type: DataType.INTEGER,
        allowNull: true,
        field: 'id_tipo_identificacion',
        references: {
            model: 'tipos_identificacion',
            key: 'id_tipo_identificacion'
        }
    })
    idTipoIdentificacion?: number;

    @Column({
        type: DataType.STRING(100),
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [2, 100]
        }
    })
    nombre!: string;

    @Column({
        type: DataType.STRING(50),
        allowNull: false,
        field: 'num_identificacion',
        validate: {
            notEmpty: true
        }
    })
    numIdentificacion!: string;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        field: 'fecha_nacimiento',
        validate: {
            isDate: true,
            isBefore: new Date().toISOString(),
            isValidAge(value: Date) {
                const age = Math.floor((new Date().getTime() - value.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
                if (age < 18) {
                    throw new Error('El empleado debe ser mayor de edad');
                }
            }
        }
    })
    fechaNacimiento!: Date;

    @Column({
        type: DataType.STRING(20),
        allowNull: false,
        validate: {
            is: /^[0-9]{10}$/
        }
    })
    telefono!: string;

    @Column({
        type: DataType.STRING(18),
        allowNull: false,
        validate: {
            is: /^[A-Z]{4}[0-9]{6}[HM][A-Z]{5}[0-9A-Z][0-9]$/
        }
    })
    curp!: string;

    @Column({
        type: DataType.STRING(200),
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [10, 200]
        }
    })
    domicilio!: string;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        field: 'fecha_contratacion',
        validate: {
            isDate: true,
            isNotFuture(value: Date) {
                if (value > new Date()) {
                    throw new Error('La fecha de contrataci√≥n no puede ser futura');
                }
            }
        }
    })
    fechaContratacion!: Date;

    @Column({
        type: DataType.STRING(20),
        allowNull: true,
        unique: true,
        field: 'num_empleado'
    })
    numEmpleado?: string;

    // Relaciones
    @BelongsTo(() => Usuario, {
        foreignKey: 'id_usuario',
        as: 'usuario'
    })
    usuario?: Usuario;

    @BelongsTo(() => TipoIdentificacion, {
        foreignKey: 'id_tipo_identificacion',
        as: 'tipoIdentificacion'
    })
    tipoIdentificacion?: TipoIdentificacion;

    @HasMany(() => Nomina, {
        foreignKey: 'id_empleado',
        as: 'nominas'
    })
    nominas?: Nomina[];

    @BelongsToMany(() => Venta, {
        through: () => VentaEmpleado,
        foreignKey: 'id_empleado',
        otherKey: 'id_venta',
        as: 'ventas'
    })
    ventas?: Venta[];

    @BelongsToMany(() => Cita, {
        through: () => CitaEmpleado,
        foreignKey: 'id_empleado',
        otherKey: 'id_cita',
        as: 'citas'
    })
    citas?: Cita[];

    @HasMany(() => Documento, {
        foreignKey: 'id_empleado',
        as: 'documentos'
    })
    documentos?: Documento[];

    // M√©todos √∫tiles
    getNombreCompleto(): string {
        return this.nombre;
    }

    getEdad(): number {
        return Math.floor((new Date().getTime() - this.fechaNacimiento.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
    }

    getAntiguedad(): number {
        return Math.floor((new Date().getTime() - this.fechaContratacion.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
    }

    // M√©todo para obtener resumen de ventas
    async getResumenVentas(options?: {
        startDate?: Date;
        endDate?: Date;
    }): Promise<{
        totalVentas: number;
        montoTotal: number;
        comisionesTotal: number;
        promedioComision: number;
        ventasPorMes: Record<string, number>;
    }> {
        const where: any = { id_empleado: this.id };
        
        if (options?.startDate && options?.endDate) {
            where.created_at = {
                [Op.between]: [options.startDate, options.endDate]
            };
        }

        const ventasEmpleado = await VentaEmpleado.findAll({
            where,
            include: [{ model: Venta, as: 'venta' }]
        });

        const ventasPorMes: Record<string, number> = {};
        let montoTotal = 0;
        let comisionesTotal = 0;

        ventasEmpleado.forEach(ve => {
            const fecha = ve.venta?.fecha.toISOString().slice(0, 7); // YYYY-MM
            if (fecha) {
                ventasPorMes[fecha] = (ventasPorMes[fecha] || 0) + 1;
            }
            montoTotal += ve.venta?.monto || 0;
            comisionesTotal += ve.comision || 0;
        });

        return {
            totalVentas: ventasEmpleado.length,
            montoTotal,
            comisionesTotal,
            promedioComision: ventasEmpleado.length ? comisionesTotal / ventasEmpleado.length : 0,
            ventasPorMes
        };
    }

    // M√©todo para obtener resumen de n√≥mina
    async getResumenNomina(options?: {
        startDate?: Date;
        endDate?: Date;
    }): Promise<{
        totalPagos: number;
        salarioPromedio: number;
        comisionesTotal: number;
        deduccionesTotal: number;
        nominasPorMes: Record<string, number>;
    }> {
        const where: any = { id_empleado: this.id };
        
        if (options?.startDate && options?.endDate) {
            where.fecha_pago = {
                [Op.between]: [options.startDate, options.endDate]
            };
        }

        const nominas = await Nomina.findAll({ where });

        const nominasPorMes: Record<string, number> = {};
        let salarioTotal = 0;
        let comisionesTotal = 0;
        let deduccionesTotal = 0;

        nominas.forEach(nomina => {
            const fecha = nomina.fechaPago.toISOString().slice(0, 7); // YYYY-MM
            nominasPorMes[fecha] = (nominasPorMes[fecha] || 0) + nomina.totalPago;
            salarioTotal += nomina.salarioBase;
            comisionesTotal += nomina.comisiones || 0;
            deduccionesTotal += nomina.deducciones || 0;
        });

        return {
            totalPagos: nominas.length,
            salarioPromedio: nominas.length ? salarioTotal / nominas.length : 0,
            comisionesTotal,
            deduccionesTotal,
            nominasPorMes
        };
    }

    // M√©todo para verificar documentos
    async verificarDocumentos(): Promise<{
        completo: boolean;
        documentosFaltantes: string[];
        documentosVencidos: string[];
    }> {
        const documentos = await this.$get('documentos');
        const documentosFaltantes: string[] = [];
        const documentosVencidos: string[] = [];

        DOCUMENTOS_REQUERIDOS.forEach(tipoDoc => {
            const documento = documentos?.find(d => d.tipoDocumento === tipoDoc);
            if (!documento) {
                documentosFaltantes.push(tipoDoc);
            } else {
                const validacion = documento.validarDocumento();
                if (!validacion.valido) {
                    documentosVencidos.push(tipoDoc);
                }
            }
        });

        return {
            completo: documentosFaltantes.length === 0 && documentosVencidos.length === 0,
            documentosFaltantes,
            documentosVencidos
        };
    }

    // M√©todo para obtener citas pendientes
    async getCitasPendientes(): Promise<Cita[]> {
        const citasEmpleado = await CitaEmpleado.findAll({
            where: { id_empleado: this.id },
            include: [{
                model: Cita,
                as: 'cita',
                where: {
                    fecha: {
                        [Op.gte]: new Date()
                    }
                }
            }]
        });

        return citasEmpleado.map(ce => ce.cita!).sort((a, b) => 
            a.fecha.getTime() - b.fecha.getTime()
        );
    }

    // M√©todo para obtener an√°lisis de rendimiento
    async getAnalisisRendimiento(options?: {
        startDate?: Date;
        endDate?: Date;
    }): Promise<{
        ventasTotales: number;
        montoTotalVentas: number;
        comisionesTotales: number;
        promedioVentasMensual: number;
        tendencia: 'Ascendente' | 'Estable' | 'Descendente';
        rendimiento: 'Alto' | 'Medio' | 'Bajo';
    }> {
        const resumenVentas = await this.getResumenVentas(options);
        const mesesTotales = Object.keys(resumenVentas.ventasPorMes).length || 1;

        // Calcular tendencia
        const ventasPorMes = Object.entries(resumenVentas.ventasPorMes)
            .sort(([a], [b]) => a.localeCompare(b));
        
        let tendencia: 'Ascendente' | 'Estable' | 'Descendente' = 'Estable';
        if (ventasPorMes.length >= 3) {
            const primerasMitad = ventasPorMes.slice(0, Math.floor(ventasPorMes.length / 2));
            const segundasMitad = ventasPorMes.slice(Math.floor(ventasPorMes.length / 2));
            
            const promedioInicial = primerasMitad.reduce((sum, [_, val]) => sum + val, 0) / primerasMitad.length;
            const promedioFinal = segundasMitad.reduce((sum, [_, val]) => sum + val, 0) / segundasMitad.length;
            
            if (promedioFinal > promedioInicial * 1.1) tendencia = 'Ascendente';
            else if (promedioFinal < promedioInicial * 0.9) tendencia = 'Descendente';
        }

        // Calcular rendimiento
        const promedioVentasMensual = resumenVentas.totalVentas / mesesTotales;
        let rendimiento: 'Alto' | 'Medio' | 'Bajo' = 'Medio';
        if (promedioVentasMensual >= 5) rendimiento = 'Alto';
        else if (promedioVentasMensual <= 2) rendimiento = 'Bajo';

        return {
            ventasTotales: resumenVentas.totalVentas,
            montoTotalVentas: resumenVentas.montoTotal,
            comisionesTotales: resumenVentas.comisionesTotal,
            promedioVentasMensual,
            tendencia,
            rendimiento
        };
    }
}

export default Empleado;import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Consignacion } from './consignacion.model';

// Tipos de conceptos comunes para gastos
export type ConceptoGasto = 'Reparaci√≥n' | 'Mantenimiento' | 'Limpieza' | 'Verificaci√≥n' | 'Tr√°mite' | 'Otro';

@Table({
    tableName: 'gastos_consignacion',
    timestamps: false
})
export class GastoConsignacion extends Model {
    @Column({
        type: DataType.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        field: 'id_gasto'
    })
    id_gasto!: number;

    @ForeignKey(() => Consignacion)
    @Column({
        type: DataType.INTEGER,
        allowNull: false,
        field: 'id_consignacion',
        references: {
            model: 'consignaciones',
            key: 'id_consignacion'
        }
    })
    id_consignacion!: number;

    @Column({
        type: DataType.STRING(100),
        allowNull: false,
        field: 'concepto',
        validate: {
            notEmpty: true,
            isIn: [['Reparaci√≥n', 'Mantenimiento', 'Limpieza', 'Verificaci√≥n', 'Tr√°mite', 'Otro']]
        }
    })
    concepto!: ConceptoGasto;

    @Column({
        type: DataType.DECIMAL(10, 2),
        allowNull: false,
        field: 'costo_total',
        validate: {
            min: 0
        }
    })
    costo_total!: number;

    @Column({
        type: DataType.DECIMAL(5, 2),
        allowNull: false,
        field: 'porcentaje_consignatario',
        validate: {
            min: 0,
            max: 100
        }
    })
    porcentaje_consignatario!: number;

    @Column({
        type: DataType.DECIMAL(5, 2),
        allowNull: false,
        field: 'porcentaje_agencia',
        validate: {
            min: 0,
            max: 100
        }
    })
    porcentaje_agencia!: number;

    // Relaciones
    @BelongsTo(() => Consignacion, {
        foreignKey: 'id_consignacion',
        as: 'consignacionGasto'
    })
    consignacion!: Consignacion;

    // M√©todos √∫tiles
    getMontoPorcentajeConsignatario(): number {
        return (this.costo_total * this.porcentaje_consignatario) / 100;
    }

    getMontoPorcentajeAgencia(): number {
        return (this.costo_total * this.porcentaje_agencia) / 100;
    }

    validarPorcentajes(): boolean {
        return this.porcentaje_consignatario + this.porcentaje_agencia === 100;
    }

    // M√©todo para obtener el resumen del gasto
    getResumen(): {
        concepto: ConceptoGasto;
        costoTotal: number;
        montoConsignatario: number;
        montoAgencia: number;
        porcentajes: {
            consignatario: number;
            agencia: number;
        };
    } {
        return {
            concepto: this.concepto,
            costoTotal: this.costo_total,
            montoConsignatario: this.getMontoPorcentajeConsignatario(),
            montoAgencia: this.getMontoPorcentajeAgencia(),
            porcentajes: {
                consignatario: this.porcentaje_consignatario,
                agencia: this.porcentaje_agencia
            }
        };
    }

    // M√©todo est√°tico para obtener el resumen de gastos de una consignaci√≥n
    static async getResumenGastosConsignacion(idConsignacion: number): Promise<{
        totalGastos: number;
        gastosPorConcepto: { [key in ConceptoGasto]?: number };
        totalConsignatario: number;
        totalAgencia: number;
        porcentajePromedioConsignatario: number;
        porcentajePromedioAgencia: number;
    }> {
        const gastos = await this.findAll({
            where: { id_consignacion: idConsignacion }
        });

        const resumen = {
            totalGastos: 0,
            gastosPorConcepto: {} as { [key in ConceptoGasto]?: number },
            totalConsignatario: 0,
            totalAgencia: 0,
            porcentajePromedioConsignatario: 0,
            porcentajePromedioAgencia: 0
        };

        if (gastos.length === 0) return resumen;

        gastos.forEach(gasto => {
            // Total general
            resumen.totalGastos += gasto.costo_total;

            // Por concepto
            resumen.gastosPorConcepto[gasto.concepto] = 
                (resumen.gastosPorConcepto[gasto.concepto] || 0) + gasto.costo_total;

            // Totales por parte
            resumen.totalConsignatario += gasto.getMontoPorcentajeConsignatario();
            resumen.totalAgencia += gasto.getMontoPorcentajeAgencia();

            // Acumular porcentajes para promedio
            resumen.porcentajePromedioConsignatario += gasto.porcentaje_consignatario;
            resumen.porcentajePromedioAgencia += gasto.porcentaje_agencia;
        });

        // Calcular promedios
        resumen.porcentajePromedioConsignatario /= gastos.length;
        resumen.porcentajePromedioAgencia /= gastos.length;

        return resumen;
    }

    // M√©todo est√°tico para validar si un gasto es v√°lido
    static validarGasto(gasto: {
        concepto: ConceptoGasto;
        costo_total: number;
        porcentaje_consignatario: number;
        porcentaje_agencia: number;
    }): { valido: boolean; errores: string[] } {
        const errores: string[] = [];

        if (!gasto.concepto || !['Reparaci√≥n', 'Mantenimiento', 'Limpieza', 'Verificaci√≥n', 'Tr√°mite', 'Otro'].includes(gasto.concepto)) {
            errores.push('El concepto no es v√°lido');
        }

        if (gasto.costo_total <= 0) {
            errores.push('El costo total debe ser mayor a 0');
        }

        if (gasto.porcentaje_consignatario < 0 || gasto.porcentaje_consignatario > 100) {
            errores.push('El porcentaje del consignatario debe estar entre 0 y 100');
        }

        if (gasto.porcentaje_agencia < 0 || gasto.porcentaje_agencia > 100) {
            errores.push('El porcentaje de la agencia debe estar entre 0 y 100');
        }

        if (gasto.porcentaje_consignatario + gasto.porcentaje_agencia !== 100) {
            errores.push('La suma de los porcentajes debe ser 100%');
        }

        return {
            valido: errores.length === 0,
            errores
        };
    }
}

export default GastoConsignacion;import { TipoTransaccion } from './catalogs/tipo-transaccion.model';
import { RolUsuario } from './catalogs/rol-usuario.model';
import { TipoIdentificacion } from './catalogs/tipo-identificacion.model';
import { Usuario } from './usuario.model';
import { Cliente } from './cliente.model';
import { Vehiculo } from './vehiculo.model';
import { Credito } from './credito.model';
import { Transaccion } from './transaccion.model';
import { Venta } from './venta.model';
import { VentaEmpleado } from './venta-empleado.model';
import { Nomina } from './nomina.model';
import { Consignacion } from './consignacion.model';
import { Contacto } from './contacto.model';
import { Cita } from './cita.model';
import { CitaEmpleado } from './cita-empleado.model';
import { Documento } from './documento.model';
import { GastoConsignacion } from './gasto-consignacion.model';
import { AjusteValorVehiculo } from './ajuste-valor-vehiculo.model';
import { LoginHistory } from './login-history.model';

// Lista de todos los modelos
const models = [
  TipoTransaccion,
  RolUsuario,
  TipoIdentificacion,
  Usuario,
  Cliente,
  Vehiculo,
  Credito,
  Transaccion,
  Venta,
  VentaEmpleado,
  Nomina,
  Consignacion,
  Contacto,
  Cita,
  CitaEmpleado,
  Documento,
  GastoConsignacion,
  AjusteValorVehiculo,
  LoginHistory
];

// Exportar modelos individuales
export {
  TipoTransaccion,
  RolUsuario,
  TipoIdentificacion,
  Usuario,
  Cliente,
  Vehiculo,
  Credito,
  Transaccion,
  Venta,
  VentaEmpleado,
  Nomina,
  Consignacion,
  Contacto,
  Cita,
  CitaEmpleado,
  Documento,
  GastoConsignacion,
  AjusteValorVehiculo,
  LoginHistory
};

// Exportar lista de modelos por defecto
export default models;import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Usuario } from './usuario.model';
import { Empleado } from './empleado.model';

// Tipos comunes de navegadores y dispositivos
export type Browser = 'Chrome' | 'Firefox' | 'Safari' | 'Edge' | 'Opera' | 'Other';
export type Device = 'Desktop' | 'Mobile' | 'Tablet' | 'Other';

@Table({
    tableName: 'login_history',
    timestamps: false
})
export class LoginHistory extends Model {
    @Column({
        type: DataType.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        field: 'id_login_history'
    })
    id_login_history!: number;

    @ForeignKey(() => Usuario)
    @Column({
        type: DataType.INTEGER,
        allowNull: false,
        field: 'id_usuario',
        references: {
            model: 'usuarios',
            key: 'id_usuario'
        }
    })
    id_usuario!: number;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW,
        field: 'fecha_login'
    })
    fecha_login!: Date;

    @Column({
        type: DataType.STRING(45),
        allowNull: false,
        field: 'ip_address',
        validate: {
            isIP: true
        }
    })
    ip_address!: string;

    @Column({
        type: DataType.TEXT,
        allowNull: false,
        field: 'user_agent'
    })
    user_agent!: string;

    @Column({
        type: DataType.STRING(100),
        allowNull: true,
        field: 'browser'
    })
    browser?: Browser;

    @Column({
        type: DataType.STRING(100),
        allowNull: true,
        field: 'device'
    })
    device?: Device;

    @Column({
        type: DataType.STRING(100),
        allowNull: true,
        field: 'country'
    })
    country?: string;

    @Column({
        type: DataType.STRING(100),
        allowNull: true,
        field: 'city'
    })
    city?: string;

    @ForeignKey(() => Empleado)
    @Column({
        type: DataType.INTEGER,
        allowNull: true,
        field: 'id_empleado',
        references: {
            model: 'empleados',
            key: 'id_empleado'
        }
    })
    id_empleado?: number;

    // Relaciones
    @BelongsTo(() => Usuario, {
        foreignKey: 'id_usuario',
        as: 'usuario'
    })
    usuario?: Usuario;

    @BelongsTo(() => Empleado, {
        foreignKey: 'id_empleado',
        as: 'empleado'
    })
    empleado?: Empleado;

    // M√©todos √∫tiles
    getLocationInfo(): { country?: string; city?: string } {
        return {
            country: this.country,
            city: this.city
        };
    }

    getDeviceInfo(): { browser?: Browser; device?: Device; userAgent: string } {
        return {
            browser: this.browser,
            device: this.device,
            userAgent: this.user_agent
        };
    }

    // M√©todo est√°tico para obtener el historial de accesos de un usuario
    static async getHistorialAccesos(idUsuario: number, options?: {
        startDate?: Date;
        endDate?: Date;
        limit?: number;
    }): Promise<LoginHistory[]> {
        const where: any = { id_usuario: idUsuario };

        if (options?.startDate && options?.endDate) {
            where.fecha_login = {
                [Op.between]: [options.startDate, options.endDate]
            };
        }

        return await this.findAll({
            where,
            order: [['fecha_login', 'DESC']],
            limit: options?.limit,
            include: [
                { model: Usuario, as: 'usuario' },
                { model: Empleado, as: 'empleado' }
            ]
        });
    }

    // M√©todo est√°tico para detectar actividad sospechosa
    static async detectarActividadSospechosa(idUsuario: number): Promise<{
        actividadSospechosa: boolean;
        razones: string[];
        accesos: LoginHistory[];
    }> {
        const ultimasHoras = 24;
        const maxAccesosPorHora = 10;
        const maxPaisesDiferentes = 3;

        const fechaLimite = new Date();
        fechaLimite.setHours(fechaLimite.getHours() - ultimasHoras);

        const accesos = await this.findAll({
            where: {
                id_usuario: idUsuario,
                fecha_login: {
                    [Op.gte]: fechaLimite
                }
            },
            order: [['fecha_login', 'DESC']]
        });

        const razones: string[] = [];

        // Verificar cantidad de accesos por hora
        const accesosPorHora = new Map<number, number>();
        accesos.forEach(acceso => {
            const hora = acceso.fecha_login.getHours();
            accesosPorHora.set(hora, (accesosPorHora.get(hora) || 0) + 1);
        });

        const excesosHora = Array.from(accesosPorHora.entries())
            .filter(([_, cantidad]) => cantidad > maxAccesosPorHora);
        
        if (excesosHora.length > 0) {
            razones.push(`Exceso de accesos por hora: ${excesosHora.map(([hora, cant]) => 
                `${cant} accesos a las ${hora}:00`).join(', ')}`);
        }

        // Verificar pa√≠ses diferentes
        const paises = new Set(accesos.map(a => a.country).filter(Boolean));
        if (paises.size > maxPaisesDiferentes) {
            razones.push(`Accesos desde ${paises.size} pa√≠ses diferentes en las √∫ltimas ${ultimasHoras} horas`);
        }

        // Verificar cambios r√°pidos de ubicaci√≥n
        const accesosOrdenados = [...accesos].sort((a, b) => 
            a.fecha_login.getTime() - b.fecha_login.getTime());
        
        for (let i = 1; i < accesosOrdenados.length; i++) {
            const tiempoEntreAccesos = accesosOrdenados[i].fecha_login.getTime() - 
                accesosOrdenados[i-1].fecha_login.getTime();
            const minutosEntreAccesos = tiempoEntreAccesos / (1000 * 60);
            
            if (accesosOrdenados[i].country !== accesosOrdenados[i-1].country && 
                minutosEntreAccesos < 60) {
                razones.push(`Cambio r√°pido de ubicaci√≥n: de ${accesosOrdenados[i-1].country} a ${
                    accesosOrdenados[i].country} en ${Math.round(minutosEntreAccesos)} minutos`);
            }
        }

        return {
            actividadSospechosa: razones.length > 0,
            razones,
            accesos
        };
    }

    // M√©todo est√°tico para obtener estad√≠sticas de acceso
    static async getEstadisticasAcceso(options?: {
        startDate?: Date;
        endDate?: Date;
        idUsuario?: number;
    }): Promise<{
        totalAccesos: number;
        accesosPorPais: { [key: string]: number };
        accesosPorDispositivo: { [key in Device]?: number };
        accesosPorNavegador: { [key in Browser]?: number };
        promedioAccesosPorDia: number;
        horasMasActivas: { hora: number; cantidad: number }[];
    }> {
        const where: any = {};

        if (options?.startDate && options?.endDate) {
            where.fecha_login = {
                [Op.between]: [options.startDate, options.endDate]
            };
        }

        if (options?.idUsuario) {
            where.id_usuario = options.idUsuario;
        }

        const accesos = await this.findAll({ where });

        const accesosPorPais: { [key: string]: number } = {};
        const accesosPorDispositivo: { [key in Device]?: number } = {};
        const accesosPorNavegador: { [key in Browser]?: number } = {};
        const accesosPorHora: { [key: number]: number } = {};

        accesos.forEach(acceso => {
            // Por pa√≠s
            if (acceso.country) {
                accesosPorPais[acceso.country] = (accesosPorPais[acceso.country] || 0) + 1;
            }

            // Por dispositivo
            if (acceso.device) {
                accesosPorDispositivo[acceso.device] = (accesosPorDispositivo[acceso.device] || 0) + 1;
            }

            // Por navegador
            if (acceso.browser) {
                accesosPorNavegador[acceso.browser] = (accesosPorNavegador[acceso.browser] || 0) + 1;
            }

            // Por hora
            const hora = acceso.fecha_login.getHours();
            accesosPorHora[hora] = (accesosPorHora[hora] || 0) + 1;
        });

        // Calcular promedio de accesos por d√≠a
        const diasTotales = options?.startDate && options?.endDate
            ? Math.ceil((options.endDate.getTime() - options.startDate.getTime()) / (1000 * 60 * 60 * 24))
            : 1;

        const horasMasActivas = Object.entries(accesosPorHora)
            .map(([hora, cantidad]) => ({ hora: parseInt(hora), cantidad }))
            .sort((a, b) => b.cantidad - a.cantidad)
            .slice(0, 5);

        return {
            totalAccesos: accesos.length,
            accesosPorPais,
            accesosPorDispositivo,
            accesosPorNavegador,
            promedioAccesosPorDia: accesos.length / diasTotales,
            horasMasActivas
        };
    }
}

export default LoginHistory;import {
  TipoTransaccion,
  RolUsuario,
  TipoIdentificacion,
  Usuario,
  Cliente,
  Vehiculo,
  Credito,
  Transaccion,
  Venta,
  VentaEmpleado,
  Nomina,
  Consignacion,
  Contacto,
  Cita,
  CitaEmpleado,
  Documento,
  GastoConsignacion,
  AjusteValorVehiculo,
  LoginHistory
} from './index';

export const initializeAssociations = () => {
  // Relaciones de Usuario
  Usuario.belongsTo(TipoIdentificacion, { foreignKey: 'id_tipo_identificacion' });
  Usuario.belongsTo(RolUsuario, { foreignKey: 'id_rol' });
  Usuario.hasMany(Transaccion, { foreignKey: 'id_usuario' });
  Usuario.hasMany(Nomina, { foreignKey: 'id_empleado' });
  Usuario.belongsToMany(Venta, { through: VentaEmpleado, foreignKey: 'id_empleado' });
  Usuario.belongsToMany(Cita, { through: CitaEmpleado, foreignKey: 'id_empleado' });
  Usuario.hasMany(Documento, { foreignKey: 'id_empleado' });

  // Relaciones de LoginHistory
  LoginHistory.belongsTo(Usuario, { foreignKey: 'id_empleado' });

  // Relaciones de Cliente
  Cliente.belongsTo(TipoIdentificacion, { foreignKey: 'id_tipo_identificacion' });
  Cliente.hasMany(Credito, { foreignKey: 'id_cliente' });
  Cliente.hasMany(Transaccion, { foreignKey: 'id_cliente' });
  Cliente.hasMany(Contacto, { foreignKey: 'id_cliente' });
  Cliente.hasMany(Documento, { foreignKey: 'id_cliente' });

  // Relaciones de Veh√≠culo
  Vehiculo.hasMany(Transaccion, { foreignKey: 'id_vehiculo' });
  Vehiculo.hasOne(Consignacion, { foreignKey: 'id_vehiculo' });
  Vehiculo.hasMany(Cita, { foreignKey: 'id_vehiculo' });
  Vehiculo.hasMany(Documento, { foreignKey: 'id_vehiculo' });
  Vehiculo.hasMany(AjusteValorVehiculo, { foreignKey: 'id_vehiculo' });

  // Relaciones de Cr√©dito
  Credito.belongsTo(Cliente, { foreignKey: 'id_cliente' });
  Credito.hasMany(Transaccion, { foreignKey: 'id_credito' });

  // Relaciones de Transacci√≥n
  Transaccion.belongsTo(Usuario, { foreignKey: 'id_usuario' });
  Transaccion.belongsTo(Cliente, { foreignKey: 'id_cliente' });
  Transaccion.belongsTo(Vehiculo, { foreignKey: 'id_vehiculo' });
  Transaccion.belongsTo(Credito, { foreignKey: 'id_credito' });
  Transaccion.belongsTo(TipoTransaccion, { foreignKey: 'id_tipo_transaccion' });
  Transaccion.hasOne(Venta, { foreignKey: 'id_transaccion' });
  Transaccion.hasMany(Documento, { foreignKey: 'id_transaccion' });

  // Relaciones de Venta
  Venta.belongsTo(Transaccion, { foreignKey: 'id_transaccion' });
  Venta.belongsToMany(Usuario, { through: VentaEmpleado, foreignKey: 'id_venta' });

  // Relaciones de Consignaci√≥n
  Consignacion.belongsTo(Vehiculo, { foreignKey: 'id_vehiculo' });
  Consignacion.hasMany(Contacto, { foreignKey: 'id_consignacion' });
  Consignacion.hasMany(GastoConsignacion, { foreignKey: 'id_consignacion' });

  // Relaciones de GastoConsignacion
  GastoConsignacion.belongsTo(Consignacion, { foreignKey: 'id_consignacion' });

  // Relaciones de AjusteValorVehiculo
  AjusteValorVehiculo.belongsTo(Vehiculo, { foreignKey: 'id_vehiculo' });

  // Relaciones de Contacto
  Contacto.belongsTo(Cliente, { foreignKey: 'id_cliente' });
  Contacto.belongsTo(Consignacion, { foreignKey: 'id_consignacion' });
  Contacto.hasMany(Cita, { foreignKey: 'id_contacto' });

  // Relaciones de Cita
  Cita.belongsTo(Usuario, { foreignKey: 'id_empleado_creador' });
  Cita.belongsTo(Contacto, { foreignKey: 'id_contacto' });
  Cita.belongsTo(Vehiculo, { foreignKey: 'id_vehiculo' });
  Cita.belongsToMany(Usuario, { through: CitaEmpleado, foreignKey: 'id_cita' });

  // Relaciones de Documento
  Documento.belongsTo(Usuario, { foreignKey: 'id_empleado' });
  Documento.belongsTo(Cliente, { foreignKey: 'id_cliente' });
  Documento.belongsTo(Vehiculo, { foreignKey: 'id_vehiculo' });
  Documento.belongsTo(Transaccion, { foreignKey: 'id_transaccion' });
};import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Empleado } from './empleado.model';

// Tipos de percepciones y deducciones
export type TipoPercepcion = 'Salario' | 'Comisi√≥n' | 'Bono' | 'Aguinaldo' | 'Prima Vacacional' | 'Otro';
export type TipoDeduccion = 'ISR' | 'IMSS' | 'INFONAVIT' | 'Pr√©stamo' | 'Otro';

@Table({
  tableName: 'nomina',
  timestamps: false
})
export class Nomina extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_nomina'
  })
  id!: number;

  @ForeignKey(() => Empleado)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_empleado',
    references: {
      model: 'empleados',
      key: 'id_empleado'
    }
  })
  idEmpleado!: number;

  @Column({
    type: DataType.DATE,
    allowNull: false,
    field: 'fecha_pago',
    validate: {
      isDate: true,
      isAfter: '2020-01-01'
    }
  })
  fechaPago!: Date;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false,
    field: 'salario_base',
    validate: {
      min: 0
    }
  })
  salarioBase!: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: true,
    defaultValue: 0,
    validate: {
      min: 0
    }
  })
  comisiones?: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: true,
    defaultValue: 0,
    field: 'otras_percepciones',
    validate: {
      min: 0
    }
  })
  otrasPercepciones?: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: true,
    defaultValue: 0,
    validate: {
      min: 0
    }
  })
  deducciones?: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false,
    field: 'total_pago',
    validate: {
      min: 0
    }
  })
  totalPago!: number;

  // Relaciones
  @BelongsTo(() => Empleado, {
    foreignKey: 'id_empleado',
    as: 'empleado'
  })
  empleado?: Empleado;

  // M√©todos √∫tiles
  calcularTotalPercepciones(): number {
    return this.salarioBase + 
           (this.comisiones || 0) + 
           (this.otrasPercepciones || 0);
  }

  calcularTotalDeducciones(): number {
    return this.deducciones || 0;
  }

  calcularTotalNeto(): number {
    return this.calcularTotalPercepciones() - this.calcularTotalDeducciones();
  }

  // M√©todo para validar los montos
  validarMontos(): boolean {
    const totalCalculado = this.calcularTotalNeto();
    return Math.abs(totalCalculado - this.totalPago) < 0.01; // Permitir peque√±as diferencias por redondeo
  }

  // M√©todo para obtener el resumen de la n√≥mina
  getResumen(): {
    percepciones: {
      salarioBase: number;
      comisiones?: number;
      otrasPercepciones?: number;
      total: number;
    };
    deducciones: {
      total: number;
    };
    totales: {
      totalPercepciones: number;
      totalDeducciones: number;
      totalNeto: number;
    };
  } {
    const totalPercepciones = this.calcularTotalPercepciones();
    const totalDeducciones = this.calcularTotalDeducciones();

    return {
      percepciones: {
        salarioBase: this.salarioBase,
        comisiones: this.comisiones,
        otrasPercepciones: this.otrasPercepciones,
        total: totalPercepciones
      },
      deducciones: {
        total: totalDeducciones
      },
      totales: {
        totalPercepciones,
        totalDeducciones,
        totalNeto: this.totalPago
      }
    };
  }

  // M√©todo est√°tico para obtener el historial de n√≥mina de un empleado
  static async getHistorialNomina(idEmpleado: number, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    nominas: Nomina[];
    totales: {
      salarioBase: number;
      comisiones: number;
      otrasPercepciones: number;
      deducciones: number;
      totalNeto: number;
    };
    promedios: {
      salarioBase: number;
      comisiones: number;
      otrasPercepciones: number;
      deducciones: number;
      totalNeto: number;
    };
  }> {
    const where: any = { id_empleado: idEmpleado };

    if (options?.startDate && options?.endDate) {
      where.fecha_pago = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const nominas = await this.findAll({
      where,
      order: [['fecha_pago', 'DESC']],
      include: [{ model: Empleado, as: 'empleado' }]
    });

    const totales = nominas.reduce((acc, nomina) => ({
      salarioBase: acc.salarioBase + nomina.salarioBase,
      comisiones: acc.comisiones + (nomina.comisiones || 0),
      otrasPercepciones: acc.otrasPercepciones + (nomina.otrasPercepciones || 0),
      deducciones: acc.deducciones + (nomina.deducciones || 0),
      totalNeto: acc.totalNeto + nomina.totalPago
    }), {
      salarioBase: 0,
      comisiones: 0,
      otrasPercepciones: 0,
      deducciones: 0,
      totalNeto: 0
    });

    const count = nominas.length || 1;
    const promedios = {
      salarioBase: totales.salarioBase / count,
      comisiones: totales.comisiones / count,
      otrasPercepciones: totales.otrasPercepciones / count,
      deducciones: totales.deducciones / count,
      totalNeto: totales.totalNeto / count
    };

    return { nominas, totales, promedios };
  }

  // M√©todo est√°tico para obtener an√°lisis de comisiones
  static async getAnalisisComisiones(idEmpleado: number, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    totalComisiones: number;
    promedioComisiones: number;
    comisionesPorMes: { [key: string]: number };
    tendencia: 'ascendente' | 'descendente' | 'estable';
  }> {
    const where: any = { 
      id_empleado: idEmpleado,
      comisiones: { [Op.gt]: 0 }
    };

    if (options?.startDate && options?.endDate) {
      where.fecha_pago = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const nominas = await this.findAll({
      where,
      order: [['fecha_pago', 'ASC']]
    });

    const comisionesPorMes: { [key: string]: number } = {};
    let totalComisiones = 0;

    nominas.forEach(nomina => {
      const mes = nomina.fechaPago.toISOString().slice(0, 7); // YYYY-MM
      comisionesPorMes[mes] = (comisionesPorMes[mes] || 0) + (nomina.comisiones || 0);
      totalComisiones += nomina.comisiones || 0;
    });

    const promedioComisiones = totalComisiones / (nominas.length || 1);

    // Calcular tendencia
    let tendencia: 'ascendente' | 'descendente' | 'estable' = 'estable';
    if (nominas.length >= 3) {
      const primeras = nominas.slice(0, Math.floor(nominas.length / 2));
      const ultimas = nominas.slice(Math.floor(nominas.length / 2));
      
      const promedioInicial = primeras.reduce((sum, n) => sum + (n.comisiones || 0), 0) / primeras.length;
      const promedioFinal = ultimas.reduce((sum, n) => sum + (n.comisiones || 0), 0) / ultimas.length;
      
      const diferencia = promedioFinal - promedioInicial;
      if (diferencia > promedioInicial * 0.1) tendencia = 'ascendente';
      else if (diferencia < -promedioInicial * 0.1) tendencia = 'descendente';
    }

    return {
      totalComisiones,
      promedioComisiones,
      comisionesPorMes,
      tendencia
    };
  }
}

export default Nomina;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, HasOne, HasMany } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Usuario } from './usuario.model';
import { Cliente } from './cliente.model';
import { Vehiculo } from './vehiculo.model';
import { Credito } from './credito.model';
import { TipoTransaccion } from './catalogs/tipo-transaccion.model';
import { Venta } from './venta.model';
import { Documento } from './documento.model';

// Tipos de transacci√≥n
export type TipoTransaccionEnum = 'Venta' | 'Compra' | 'Pago Cr√©dito' | 'Consignaci√≥n' | 'Otro';

// Estados de transacci√≥n
export type EstadoTransaccion = 'Pendiente' | 'Completada' | 'Cancelada' | 'En Proceso';

@Table({
  tableName: 'transacciones',
  timestamps: false,
  schema: 'public',
  comment: 'Tabla particionada por fecha'
})
export class Transaccion extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_transaccion'
  })
  id!: number;

  @Column({
    type: DataType.DATE,
    allowNull: false,
    primaryKey: true,
    field: 'fecha',
    validate: {
      isDate: true,
      isAfter: '2020-01-01'
    }
  })
  fecha!: Date;

  @ForeignKey(() => Usuario)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_usuario',
    references: {
      model: 'usuarios',
      key: 'id_usuario'
    }
  })
  idUsuario!: number;

  @ForeignKey(() => Cliente)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_cliente',
    references: {
      model: 'clientes',
      key: 'id_cliente'
    }
  })
  idCliente!: number;

  @ForeignKey(() => Vehiculo)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_vehiculo',
    references: {
      model: 'vehiculos',
      key: 'id_vehiculo'
    }
  })
  idVehiculo!: number;

  @ForeignKey(() => Credito)
  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'id_credito',
    references: {
      model: 'creditos',
      key: 'id_credito'
    }
  })
  idCredito?: number;

  @ForeignKey(() => TipoTransaccion)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_tipo_transaccion',
    references: {
      model: 'tipos_transaccion',
      key: 'id_tipo_transaccion'
    }
  })
  idTipoTransaccion!: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0,
    field: 'monto',
    validate: {
      min: 0
    }
  })
  monto!: number;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'nombre_cliente'
  })
  nombreCliente?: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'marca_vehiculo'
  })
  marcaVehiculo?: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'modelo_vehiculo'
  })
  modeloVehiculo?: string;

  // Relaciones
  @BelongsTo(() => Usuario, { foreignKey: 'id_usuario', as: 'usuarioTransaccion' })
  usuario!: Usuario;

  @BelongsTo(() => Cliente, { foreignKey: 'id_cliente', as: 'cliente' })
  cliente!: Cliente;

  @BelongsTo(() => Vehiculo, { foreignKey: 'id_vehiculo', as: 'vehiculo' })
  vehiculo!: Vehiculo;

  @BelongsTo(() => Credito, { foreignKey: 'id_credito', as: 'credito' })
  credito?: Credito;

  @BelongsTo(() => TipoTransaccion, { foreignKey: 'id_tipo_transaccion', as: 'tipoTransaccion' })
  tipoTransaccion!: TipoTransaccion;

  @HasOne(() => Venta, { foreignKey: 'id_transaccion', as: 'venta' })
  venta?: Venta;

  @HasMany(() => Documento, { foreignKey: 'id_transaccion', as: 'documentos' })
  documentos?: Documento[];

  // M√©todos √∫tiles
  isPagoCredito(): boolean {
    return this.idTipoTransaccion === 3; // ID 3 para pagos de cr√©dito
  }

  // M√©todo para obtener el estado de la transacci√≥n
  async getEstadoTransaccion(): Promise<EstadoTransaccion> {
    const documentos = await this.$get('documentos');
    
    if (!documentos?.length) return 'Pendiente';
    
    const documentosRequeridos = ['Contrato', 'Factura'];
    const tieneDocumentosRequeridos = documentosRequeridos.every(tipo =>
      documentos.some(doc => doc.tipoDocumento === tipo && doc.estado === 'aprobado')
    );

    if (tieneDocumentosRequeridos) return 'Completada';
    if (documentos.some(doc => doc.estado === 'rechazado')) return 'Cancelada';
    return 'En Proceso';
  }

  // M√©todo para obtener el resumen de la transacci√≥n
  async getResumenTransaccion(): Promise<{
    tipo: TipoTransaccionEnum;
    monto: number;
    fecha: Date;
    cliente: {
      id: number;
      nombre: string;
    };
    vehiculo: {
      id: number;
      marca: string;
      modelo: string;
    };
    credito?: {
      id: number;
      monto: number;
      estado: string;
    };
    documentos: {
      pendientes: number;
      aprobados: number;
      rechazados: number;
    };
    estado: EstadoTransaccion;
  }> {
    const [tipoTransaccion, documentos, estado] = await Promise.all([
      this.$get('tipoTransaccion'),
      this.$get('documentos'),
      this.getEstadoTransaccion()
    ]);

    const documentosEstado = {
      pendientes: documentos?.filter(d => d.estado === 'pendiente').length || 0,
      aprobados: documentos?.filter(d => d.estado === 'aprobado').length || 0,
      rechazados: documentos?.filter(d => d.estado === 'rechazado').length || 0
    };

    const resumen: any = {
      tipo: tipoTransaccion?.nombre as TipoTransaccionEnum,
      monto: this.monto,
      fecha: this.fecha,
      cliente: {
        id: this.idCliente,
        nombre: this.nombreCliente || ''
      },
      vehiculo: {
        id: this.idVehiculo,
        marca: this.marcaVehiculo || '',
        modelo: this.modeloVehiculo || ''
      },
      documentos: documentosEstado,
      estado
    };

    if (this.idCredito) {
      const credito = await this.$get('credito');
      resumen.credito = {
        id: this.idCredito,
        monto: credito?.cantidad || 0,
        estado: credito ? 'Activo' : 'Pendiente'
      };
    }

    return resumen;
  }

  // M√©todo est√°tico para obtener transacciones por per√≠odo
  static async getTransaccionesPorPeriodo(options?: {
    startDate?: Date;
    endDate?: Date;
    tipo?: TipoTransaccionEnum;
    idCliente?: number;
    idVehiculo?: number;
  }): Promise<{
    transacciones: Transaccion[];
    totalTransacciones: number;
    montoTotal: number;
    promedioMonto: number;
    transaccionesPorTipo: { [key in TipoTransaccionEnum]?: number };
    transaccionesPorEstado: { [key in EstadoTransaccion]?: number };
  }> {
    const where: any = {};
    
    if (options?.startDate && options?.endDate) {
      where.fecha = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    if (options?.tipo) {
      where['$tipoTransaccion.nombre$'] = options.tipo;
    }

    if (options?.idCliente) {
      where.id_cliente = options.idCliente;
    }

    if (options?.idVehiculo) {
      where.id_vehiculo = options.idVehiculo;
    }

    const transacciones = await this.findAll({
      where,
      include: [
        { model: TipoTransaccion, as: 'tipoTransaccion' },
        { model: Cliente, as: 'cliente' },
        { model: Vehiculo, as: 'vehiculo' },
        { model: Credito, as: 'credito' },
        { model: Documento, as: 'documentos' }
      ]
    });

    const transaccionesConEstado = await Promise.all(
      transacciones.map(async t => ({
        transaccion: t,
        estado: await t.getEstadoTransaccion()
      }))
    );

    const montoTotal = transacciones.reduce((sum, t) => sum + t.monto, 0);

    const transaccionesPorTipo = transacciones.reduce((acc, t) => {
      const tipo = t.tipoTransaccion?.nombre as TipoTransaccionEnum;
      acc[tipo] = (acc[tipo] || 0) + 1;
      return acc;
    }, {} as { [key in TipoTransaccionEnum]?: number });

    const transaccionesPorEstado = transaccionesConEstado.reduce((acc, { estado }) => {
      acc[estado] = (acc[estado] || 0) + 1;
      return acc;
    }, {} as { [key in EstadoTransaccion]?: number });

    return {
      transacciones,
      totalTransacciones: transacciones.length,
      montoTotal,
      promedioMonto: montoTotal / transacciones.length,
      transaccionesPorTipo,
      transaccionesPorEstado
    };
  }
}

export default Transaccion;import { Table, Column, Model, DataType, HasMany, HasOne, BelongsTo, ForeignKey } from 'sequelize-typescript';
import { hashPassword, comparePassword, generarToken } from '../middlewares/auth.middleware';
import { LoginCredentials, RolUsuario as RolUsuarioEnum } from '../types';
import * as UAParser from 'ua-parser-js';
import * as geoip from 'geoip-lite';
import { LoginHistory } from './login-history.model';
import { Empleado } from './empleado.model';
import { TipoIdentificacion } from './catalogs/tipo-identificacion.model';
import { RolUsuario } from './catalogs/rol-usuario.model';

// Mapeo entre IDs de rol y RolUsuario enum
const rolMapping: { [key: number]: RolUsuarioEnum } = {
  1: RolUsuarioEnum.Administrador,
  2: RolUsuarioEnum.Ventas,
  3: RolUsuarioEnum.RRHH,
  4: RolUsuarioEnum.Gerente_general,
  5: RolUsuarioEnum.Capturista
};

@Table({
  tableName: 'usuarios',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at'
})
export class Usuario extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_usuario'
  })
  id!: number;

  @Column({
    type: DataType.STRING(100),
    allowNull: false,
    unique: true
  })
  correo!: string;

  @ForeignKey(() => TipoIdentificacion)
  @Column({
    type: DataType.INTEGER,
    field: 'id_tipo_identificacion',
    allowNull: true
  })
  idTipoIdentificacion?: number;

  @ForeignKey(() => RolUsuario)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_rol'
  })
  id_rol!: number;

  @Column({
    type: DataType.STRING(255),
    allowNull: false
  })
  password!: string;

  @Column({
    type: DataType.BOOLEAN,
    allowNull: false,
    defaultValue: true,
    field: 'is_active'
  })
  is_active!: boolean;

  @Column({
    type: DataType.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    field: 'is_locked'
  })
  is_locked!: boolean;

  @Column({
    type: DataType.DATE,
    allowNull: true,
    field: 'last_login'
  })
  last_login?: Date;

  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'failed_attempts'
  })
  failed_attempts!: number;

  @Column({
    type: DataType.DATE,
    allowNull: true,
    field: 'password_changed_at'
  })
  password_changed_at?: Date;

  @Column({
    type: DataType.STRING(255),
    allowNull: true,
    field: 'reset_password_token'
  })
  reset_password_token?: string;

  @Column({
    type: DataType.DATE,
    allowNull: true,
    field: 'reset_password_expires_at'
  })
  reset_password_expires_at?: Date;

  @Column({
    type: DataType.INTEGER,
    allowNull: true,
    field: 'created_by',
    references: {
      model: 'usuarios',
      key: 'id_usuario'
    }
  })
  created_by?: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'auth_provider'
  })
  auth_provider?: string;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'auth_provider_id'
  })
  auth_provider_id?: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    unique: true
  })
  username?: string;

  @Column({
    type: DataType.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    field: 'two_factor_enabled'
  })
  two_factor_enabled!: boolean;

  @Column({
    type: DataType.STRING(100),
    allowNull: true,
    field: 'two_factor_secret'
  })
  two_factor_secret?: string;

  // Relaciones
  @BelongsTo(() => TipoIdentificacion)
  tipoIdentificacion?: TipoIdentificacion;

  @BelongsTo(() => RolUsuario, { foreignKey: 'id_rol' })
  rol!: RolUsuario;

  @HasMany(() => LoginHistory, {
    foreignKey: 'id_usuario',
    as: 'historialLogin'
  })
  historialLogin?: LoginHistory[];

  @HasOne(() => Empleado, {
    foreignKey: 'id_usuario',
    as: 'empleado'
  })
  empleado?: Empleado;

  // M√©todo para obtener el rol como enum
  public getRolEnum(): RolUsuarioEnum {
    return rolMapping[this.id_rol] || RolUsuarioEnum.Capturista;
  }

  private static async recordLoginHistory(
    usuario: Usuario,
    ip_address: string,
    user_agent: string
  ) {
    try {
      const parser = new UAParser.UAParser();
      parser.setUA(user_agent);
      const result = parser.getResult();
      const geo = geoip.lookup(ip_address);
      
      const browser = `${result.browser.name || ''} ${result.browser.version || ''}`.trim();
      const device = `${result.device.vendor || ''} ${result.device.model || ''} ${result.os.name || ''}`.trim();

      await LoginHistory.create({
        id_usuario: usuario.id,
        fecha_login: new Date(),
        ip_address,
        user_agent,
        browser,
        device,
        country: geo?.country || 'Unknown',
        city: geo?.city || 'Unknown'
      });
    } catch (error) {
      console.error('Error al registrar historial de login:', error);
      // No lanzamos el error para no interrumpir el login
    }
  }

  // M√©todo est√°tico para el login
  public static async login(credentials: LoginCredentials): Promise<{ token: string; usuario: any; lastLogin?: any } | null> {
    try {
      const whereClause = credentials.employeeId 
        ? { '$empleado.num_empleado$': credentials.employeeId }
        : { correo: credentials.correo };

      console.log('üîç Buscando usuario con:', whereClause);
      
      const usuario = await Usuario.findOne({
        where: whereClause,
        include: [{
          model: Empleado,
          as: 'empleado'
        }]
      });

      if (!usuario) {
        console.log('‚ùå Usuario no encontrado');
        return null;
      }

      console.log('‚úÖ Usuario encontrado, verificando contrase√±a');
      const isPasswordValid = await comparePassword(credentials.password, usuario.password);
      
      if (!isPasswordValid) {
        console.log('‚ùå Contrase√±a inv√°lida');
        return null;
      }

      console.log('‚úÖ Contrase√±a v√°lida, generando token');
      const token = generarToken({
        id_usuario: usuario.id,
        rol: usuario.getRolEnum()
      });

      // Registrar el historial de login si se proporcionaron los datos
      if (credentials.ip_address && credentials.user_agent) {
        await this.recordLoginHistory(
          usuario,
          credentials.ip_address,
          credentials.user_agent
        );
      }

      // Obtener el √∫ltimo login
      const lastLogin = await LoginHistory.findOne({
        where: { id_usuario: usuario.id },
        order: [['fecha_login', 'DESC']]
      });

      // Excluir la contrase√±a de la respuesta
      const { password, ...usuarioSinPassword } = usuario.toJSON();
      
      console.log('‚úÖ Login exitoso');
      return {
        token,
        usuario: usuarioSinPassword,
        lastLogin
      };
    } catch (error) {
      console.error('‚ùå Error en login:', error);
      throw new Error(`Error en el login: ${(error as Error).message}`);
    }
  }
}

export default Usuario;import { Table, Column, Model, DataType, HasMany, HasOne } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Transaccion } from './transaccion.model';
import { Consignacion } from './consignacion.model';
import { Cita } from './cita.model';
import { Documento } from './documento.model';
import { AjusteValorVehiculo } from './ajuste-valor-vehiculo.model';

// Tipos comunes de marcas y modelos
export type MarcaVehiculo = 'Toyota' | 'Honda' | 'Nissan' | 'Volkswagen' | 'Ford' | 'Chevrolet' | 'Otro';

@Table({
  tableName: 'vehiculos',
  timestamps: false
})
export class Vehiculo extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_vehiculo'
  })
  id!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true
    }
  })
  marca!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true
    }
  })
  modelo!: string;

  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'anio',
    validate: {
      min: 1900,
      max: new Date().getFullYear() + 1
    }
  })
  anio!: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false,
    validate: {
      min: 0
    }
  })
  precio!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'num_serie',
    validate: {
      notEmpty: true,
      len: [17, 17] // VIN est√°ndar
    }
  })
  numSerie!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true
    }
  })
  color!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    field: 'num_motor',
    validate: {
      notEmpty: true
    }
  })
  numMotor!: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'num_factura'
  })
  numFactura?: string;

  @Column({
    type: DataType.STRING(20),
    allowNull: true
  })
  placas?: string;

  @Column({
    type: DataType.STRING(50),
    allowNull: true,
    field: 'tarjeta_circulacion'
  })
  tarjetaCirculacion?: string;

  @Column({
    type: DataType.TEXT,
    allowNull: true,
    field: 'comentarios_internos'
  })
  comentariosInternos?: string;

  // Relaciones
  @HasMany(() => Transaccion, { foreignKey: 'id_vehiculo', as: 'transacciones' })
  transacciones?: Transaccion[];

  @HasOne(() => Consignacion, { foreignKey: 'id_vehiculo', as: 'consignacionVehiculo' })
  consignacion?: Consignacion;

  @HasMany(() => Cita, { foreignKey: 'id_vehiculo', as: 'citas' })
  citas?: Cita[];

  @HasMany(() => Documento, { foreignKey: 'id_vehiculo', as: 'documentos' })
  documentos?: Documento[];

  @HasMany(() => AjusteValorVehiculo, { foreignKey: 'id_vehiculo', as: 'ajustes' })
  ajustesValor?: AjusteValorVehiculo[];

  // M√©todos √∫tiles
  getNombreCompleto(): string {
    return `${this.marca} ${this.modelo} ${this.anio}`;
  }

  async getValorActual(): Promise<number> {
    const ajustes = await this.getAjustesValor();
    const totalAjustes = ajustes?.reduce((total, ajuste) => total + ajuste.monto_ajuste, 0) || 0;
    return this.precio + totalAjustes;
  }

  async getAjustesValor(): Promise<AjusteValorVehiculo[]> {
    return await AjusteValorVehiculo.findAll({
      where: { id_vehiculo: this.id },
      order: [['fecha', 'DESC']]
    });
  }

  async getDocumentosPorTipo(tipo: string): Promise<Documento[]> {
    return await Documento.findAll({
      where: {
        id_vehiculo: this.id,
        tipo_documento: tipo
      },
      order: [['fecha_subida', 'DESC']]
    });
  }

  async getCitasPendientes(): Promise<Cita[]> {
    return await Cita.findAll({
      where: {
        id_vehiculo: this.id,
        fecha: {
          [Op.gte]: new Date()
        }
      },
      order: [['fecha', 'ASC'], ['hora', 'ASC']]
    });
  }

  async getHistorialTransacciones(): Promise<Transaccion[]> {
    return await Transaccion.findAll({
      where: { id_vehiculo: this.id },
      include: [
        { model: Documento, as: 'documentos' }
      ],
      order: [['fecha', 'DESC']]
    });
  }

  // M√©todo para verificar si el veh√≠culo est√° en consignaci√≥n
  async estaEnConsignacion(): Promise<boolean> {
    const consignacion = await Consignacion.findOne({
      where: { id_vehiculo: this.id }
    });
    return !!consignacion;
  }

  // M√©todo para obtener el historial de precios
  async getHistorialPrecios(): Promise<{
    precioOriginal: number;
    ajustes: AjusteValorVehiculo[];
    precioActual: number;
  }> {
    const ajustes = await this.getAjustesValor();
    const precioActual = await this.getValorActual();

    return {
      precioOriginal: this.precio,
      ajustes,
      precioActual
    };
  }

  // M√©todo est√°tico para buscar veh√≠culos disponibles
  static async getVehiculosDisponibles(filtros?: {
    marca?: string;
    modelo?: string;
    anioMin?: number;
    anioMax?: number;
    precioMin?: number;
    precioMax?: number;
  }): Promise<Vehiculo[]> {
    const where: any = {};

    if (filtros?.marca) where.marca = filtros.marca;
    if (filtros?.modelo) where.modelo = filtros.modelo;
    if (filtros?.anioMin) where.anio = { ...where.anio, [Op.gte]: filtros.anioMin };
    if (filtros?.anioMax) where.anio = { ...where.anio, [Op.lte]: filtros.anioMax };
    if (filtros?.precioMin) where.precio = { ...where.precio, [Op.gte]: filtros.precioMin };
    if (filtros?.precioMax) where.precio = { ...where.precio, [Op.lte]: filtros.precioMax };

    return await this.findAll({
      where,
      include: [
        {
          model: Transaccion,
          as: 'transacciones',
          required: false
        },
        {
          model: Consignacion,
          as: 'consignacionVehiculo',
          required: false
        }
      ],
      order: [['marca', 'ASC'], ['modelo', 'ASC'], ['anio', 'DESC']]
    });
  }
}

export default Vehiculo;import { Table, Column, Model, DataType, ForeignKey, BelongsTo } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Venta } from './venta.model';
import { Empleado } from './empleado.model';

// Tipos de comisi√≥n
export type TipoComision = 'Fija' | 'Porcentaje' | 'Mixta';

@Table({
  tableName: 'venta_empleados',
  timestamps: false
})
export class VentaEmpleado extends Model {
  @ForeignKey(() => Venta)
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    field: 'id_venta',
    references: {
      model: 'ventas',
      key: 'id_venta'
    }
  })
  idVenta!: number;

  @ForeignKey(() => Empleado)
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    field: 'id_empleado',
    references: {
      model: 'empleados',
      key: 'id_empleado'
    }
  })
  idEmpleado!: number;

  @Column({
    type: DataType.DECIMAL(10, 2),
    allowNull: false,
    validate: {
      min: 0
    }
  })
  comision!: number;

  @Column({
    type: DataType.DECIMAL(5, 2),
    allowNull: false,
    field: 'porcentaje_comision',
    validate: {
      min: 0,
      max: 100
    }
  })
  porcentajeComision!: number;

  // Relaciones
  @BelongsTo(() => Venta, {
    foreignKey: 'id_venta',
    as: 'venta'
  })
  venta?: Venta;

  @BelongsTo(() => Empleado, {
    foreignKey: 'id_empleado',
    as: 'empleado'
  })
  empleado?: Empleado;

  // M√©todos √∫tiles
  calcularComision(montoVenta: number): number {
    return (montoVenta * this.porcentajeComision) / 100;
  }

  async actualizarComision(montoVenta: number): Promise<void> {
    this.comision = this.calcularComision(montoVenta);
    await this.save();
  }

  // M√©todo para validar la comisi√≥n
  validarComision(montoVenta: number): boolean {
    const comisionCalculada = this.calcularComision(montoVenta);
    return Math.abs(comisionCalculada - this.comision) < 0.01; // Permitir peque√±as diferencias por redondeo
  }

  // M√©todo para obtener el resumen de la venta
  getResumenVenta(): {
    montoComision: number;
    porcentaje: number;
    rendimiento: 'Alto' | 'Medio' | 'Bajo';
  } {
    let rendimiento: 'Alto' | 'Medio' | 'Bajo' = 'Medio';
    
    if (this.porcentajeComision > 5) rendimiento = 'Alto';
    else if (this.porcentajeComision < 2) rendimiento = 'Bajo';

    return {
      montoComision: this.comision,
      porcentaje: this.porcentajeComision,
      rendimiento
    };
  }

  // M√©todo est√°tico para obtener el historial de ventas de un empleado
  static async getHistorialVentas(idEmpleado: number, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    ventas: VentaEmpleado[];
    totalComisiones: number;
    promedioComision: number;
    rendimientoGeneral: 'Alto' | 'Medio' | 'Bajo';
  }> {
    const where: any = { id_empleado: idEmpleado };

    if (options?.startDate && options?.endDate) {
      where['$venta.fecha$'] = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const ventas = await this.findAll({
      where,
      include: [
        { model: Venta, as: 'venta' },
        { model: Empleado, as: 'empleado' }
      ],
      order: [[{ model: Venta, as: 'venta' }, 'fecha', 'DESC']]
    });

    const totalComisiones = ventas.reduce((sum, venta) => sum + venta.comision, 0);
    const promedioComision = totalComisiones / (ventas.length || 1);
    const promedioProcentaje = ventas.reduce((sum, venta) => sum + venta.porcentajeComision, 0) / (ventas.length || 1);

    let rendimientoGeneral: 'Alto' | 'Medio' | 'Bajo' = 'Medio';
    if (promedioProcentaje > 5) rendimientoGeneral = 'Alto';
    else if (promedioProcentaje < 2) rendimientoGeneral = 'Bajo';

    return {
      ventas,
      totalComisiones,
      promedioComision,
      rendimientoGeneral
    };
  }

  // M√©todo est√°tico para obtener an√°lisis de rendimiento
  static async getAnalisisRendimiento(idEmpleado: number, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    totalVentas: number;
    totalComisiones: number;
    promedioComisionPorVenta: number;
    mejorComision: number;
    peorComision: number;
    tendencia: 'Mejorando' | 'Estable' | 'Decreciendo';
    distribucionComisiones: {
      alta: number;
      media: number;
      baja: number;
    };
  }> {
    const where: any = { id_empleado: idEmpleado };

    if (options?.startDate && options?.endDate) {
      where['$venta.fecha$'] = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const ventas = await this.findAll({
      where,
      include: [{ model: Venta, as: 'venta' }],
      order: [[{ model: Venta, as: 'venta' }, 'fecha', 'ASC']]
    });

    const comisiones = ventas.map(v => v.comision);
    const totalComisiones = comisiones.reduce((sum, c) => sum + c, 0);
    const promedioComision = totalComisiones / (ventas.length || 1);

    // An√°lisis de tendencia
    let tendencia: 'Mejorando' | 'Estable' | 'Decreciendo' = 'Estable';
    if (ventas.length >= 3) {
      const mitad = Math.floor(ventas.length / 2);
      const primerasMitad = ventas.slice(0, mitad);
      const segundasMitad = ventas.slice(mitad);

      const promedioInicial = primerasMitad.reduce((sum, v) => sum + v.comision, 0) / primerasMitad.length;
      const promedioFinal = segundasMitad.reduce((sum, v) => sum + v.comision, 0) / segundasMitad.length;

      if (promedioFinal > promedioInicial * 1.1) tendencia = 'Mejorando';
      else if (promedioFinal < promedioInicial * 0.9) tendencia = 'Decreciendo';
    }

    // Distribuci√≥n de comisiones
    const distribucionComisiones = {
      alta: ventas.filter(v => v.porcentajeComision > 5).length,
      media: ventas.filter(v => v.porcentajeComision >= 2 && v.porcentajeComision <= 5).length,
      baja: ventas.filter(v => v.porcentajeComision < 2).length
    };

    return {
      totalVentas: ventas.length,
      totalComisiones,
      promedioComisionPorVenta: promedioComision,
      mejorComision: Math.max(...comisiones),
      peorComision: Math.min(...comisiones),
      tendencia,
      distribucionComisiones
    };
  }
}

export default VentaEmpleado;import { Table, Column, Model, DataType, ForeignKey, BelongsTo, BelongsToMany, HasMany } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Transaccion } from './transaccion.model';
import { Empleado } from './empleado.model';
import { VentaEmpleado } from './venta-empleado.model';
import { Documento } from './documento.model';

// Estados de venta
export type EstadoVenta = 'Pendiente' | 'Completada' | 'Cancelada' | 'En Proceso';

@Table({
  tableName: 'ventas',
  timestamps: false
})
export class Venta extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_venta'
  })
  id!: number;

  @ForeignKey(() => Transaccion)
  @Column({
    type: DataType.INTEGER,
    allowNull: false,
    field: 'id_transaccion',
    references: {
      model: 'transacciones',
      key: 'id_transaccion'
    }
  })
  idTransaccion!: number;

  // Relaciones
  @BelongsTo(() => Transaccion, {
    foreignKey: 'id_transaccion',
    as: 'transaccion'
  })
  transaccion?: Transaccion;

  @BelongsToMany(() => Empleado, {
    through: () => VentaEmpleado,
    foreignKey: 'id_venta',
    otherKey: 'id_empleado',
    as: 'empleados'
  })
  empleados?: Empleado[];

  @HasMany(() => VentaEmpleado, {
    foreignKey: 'id_venta',
    as: 'ventaEmpleados'
  })
  ventaEmpleados?: VentaEmpleado[];

  @HasMany(() => Documento, {
    foreignKey: 'id_transaccion',
    as: 'documentos'
  })
  documentos?: Documento[];

  // M√©todos √∫tiles
  async getTotalComisiones(): Promise<number> {
    const ventaEmpleados = await this.$get('ventaEmpleados');
    return ventaEmpleados?.reduce((total, ve) => total + (ve.comision || 0), 0) || 0;
  }

  async getMontoVenta(): Promise<number> {
    const transaccion = await this.$get('transaccion', {
      include: [{ model: Documento, as: 'documentos' }]
    });
    return transaccion?.monto || 0;
  }

  // M√©todo para obtener el estado de la venta
  async getEstadoVenta(): Promise<EstadoVenta> {
    const transaccion = await this.$get('transaccion');
    const documentos = await this.$get('documentos');
    
    if (!transaccion) return 'Pendiente';
    
    const documentosRequeridos = ['Contrato', 'Factura'];
    const tieneDocumentosRequeridos = documentosRequeridos.every(tipo =>
      documentos?.some(doc => doc.tipoDocumento === tipo && doc.estado === 'aprobado')
    );

    if (tieneDocumentosRequeridos) return 'Completada';
    if (documentos?.some(doc => doc.estado === 'rechazado')) return 'Cancelada';
    return 'En Proceso';
  }

  // M√©todo para obtener el resumen de la venta
  async getResumenVenta(): Promise<{
    montoVenta: number;
    totalComisiones: number;
    porcentajeComisiones: number;
    empleadosParticipantes: number;
    documentosEstado: {
      pendientes: number;
      aprobados: number;
      rechazados: number;
    };
    estado: EstadoVenta;
  }> {
    const [montoVenta, totalComisiones, documentos, estado] = await Promise.all([
      this.getMontoVenta(),
      this.getTotalComisiones(),
      this.$get('documentos'),
      this.getEstadoVenta()
    ]);

    const documentosEstado = {
      pendientes: documentos?.filter(d => d.estado === 'pendiente').length || 0,
      aprobados: documentos?.filter(d => d.estado === 'aprobado').length || 0,
      rechazados: documentos?.filter(d => d.estado === 'rechazado').length || 0
    };

    const ventaEmpleados = await this.$get('ventaEmpleados');

    return {
      montoVenta,
      totalComisiones,
      porcentajeComisiones: montoVenta ? (totalComisiones / montoVenta) * 100 : 0,
      empleadosParticipantes: ventaEmpleados?.length || 0,
      documentosEstado,
      estado
    };
  }

  // M√©todo est√°tico para obtener ventas por per√≠odo
  static async getVentasPorPeriodo(options?: {
    startDate?: Date;
    endDate?: Date;
    estado?: EstadoVenta;
  }): Promise<{
    ventas: Venta[];
    totalVentas: number;
    montoTotal: number;
    comisionesTotal: number;
    promedioComisiones: number;
    ventasPorEstado: { [key in EstadoVenta]?: number };
  }> {
    const where: any = {};
    
    if (options?.startDate && options?.endDate) {
      where['$transaccion.fecha$'] = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const ventas = await this.findAll({
      where,
      include: [
        {
          model: Transaccion,
          as: 'transaccion',
          required: true
        },
        {
          model: VentaEmpleado,
          as: 'ventaEmpleados'
        },
        {
          model: Documento,
          as: 'documentos'
        }
      ]
    });

    const ventasConEstado = await Promise.all(
      ventas.map(async venta => ({
        venta,
        estado: await venta.getEstadoVenta()
      }))
    );

    const ventasFiltradas = options?.estado
      ? ventasConEstado.filter(v => v.estado === options.estado).map(v => v.venta)
      : ventas;

    const montoTotal = await ventasFiltradas.reduce(
      async (promise, venta) => (await promise) + await venta.getMontoVenta(),
      Promise.resolve(0)
    );

    const comisionesTotal = await ventasFiltradas.reduce(
      async (promise, venta) => (await promise) + await venta.getTotalComisiones(),
      Promise.resolve(0)
    );

    const ventasPorEstado = ventasConEstado.reduce((acc, { estado }) => {
      acc[estado] = (acc[estado] || 0) + 1;
      return acc;
    }, {} as { [key in EstadoVenta]?: number });

    return {
      ventas: ventasFiltradas,
      totalVentas: ventasFiltradas.length,
      montoTotal,
      comisionesTotal,
      promedioComisiones: ventasFiltradas.length ? comisionesTotal / ventasFiltradas.length : 0,
      ventasPorEstado
    };
  }
}

export default Venta;import { Table, Column, Model, DataType, HasMany, Sequelize } from 'sequelize-typescript';
import { Op } from 'sequelize';
import { Usuario } from '../usuario.model';

// Tipo para los IDs de rol
export type RolUsuarioId = 1 | 2 | 3 | 4 | 5;

// Tipos de roles
export type RolUsuarioNombre = 
  'Administrador' | 
  'Gerente' | 
  'Ventas' | 
  'Finanzas' | 
  'Capturista';

// Tipo para permisos
export type Permiso = string;

// Constantes para los roles
export const ROLES_USUARIO = {
  ADMIN: 1 as RolUsuarioId,
  GERENTE: 2 as RolUsuarioId,
  VENTAS: 3 as RolUsuarioId,
  FINANZAS: 4 as RolUsuarioId,
  CAPTURISTA: 5 as RolUsuarioId
} as const;

// Tipo para la configuraci√≥n de un rol
type RolConfig = {
  nombre: RolUsuarioNombre;
  descripcion: string;
  nivel: number;
  permisos: Permiso[];
  puedeCrearUsuarios: boolean;
  puedeEliminarRegistros: boolean;
  accesoTotal: boolean;
};

// Descripciones y permisos por rol
const permisosRolConfig: Record<RolUsuarioId, RolConfig> = {
  1: {
    nombre: 'Administrador',
    descripcion: 'Control total del sistema',
    nivel: 1,
    permisos: ['*'],
    puedeCrearUsuarios: true,
    puedeEliminarRegistros: true,
    accesoTotal: true
  },
  2: {
    nombre: 'Gerente',
    descripcion: 'Gesti√≥n general y reportes',
    nivel: 2,
    permisos: [
      'ver_reportes',
      'gestionar_empleados',
      'gestionar_inventario',
      'gestionar_ventas',
      'gestionar_creditos',
      'gestionar_consignaciones'
    ],
    puedeCrearUsuarios: true,
    puedeEliminarRegistros: false,
    accesoTotal: false
  },
  3: {
    nombre: 'Ventas',
    descripcion: 'Gesti√≥n de ventas y clientes',
    nivel: 3,
    permisos: [
      'gestionar_ventas',
      'gestionar_clientes',
      'ver_inventario',
      'crear_citas'
    ],
    puedeCrearUsuarios: false,
    puedeEliminarRegistros: false,
    accesoTotal: false
  },
  4: {
    nombre: 'Finanzas',
    descripcion: 'Gesti√≥n financiera y cr√©ditos',
    nivel: 3,
    permisos: [
      'gestionar_creditos',
      'ver_reportes_financieros',
      'gestionar_pagos',
      'ver_ventas'
    ],
    puedeCrearUsuarios: false,
    puedeEliminarRegistros: false,
    accesoTotal: false
  },
  5: {
    nombre: 'Capturista',
    descripcion: 'Captura de informaci√≥n b√°sica',
    nivel: 4,
    permisos: [
      'capturar_datos',
      'ver_inventario',
      'crear_citas'
    ],
    puedeCrearUsuarios: false,
    puedeEliminarRegistros: false,
    accesoTotal: false
  }
};

export const PERMISOS_ROL = permisosRolConfig;

// Jerarqu√≠a de roles para herencia de permisos
const jerarquiaRolesConfig: Record<RolUsuarioId, RolUsuarioId[]> = {
  1: [],
  2: [1],
  3: [2],
  4: [2],
  5: [3, 4]
};

export const JERARQUIA_ROLES = jerarquiaRolesConfig;

@Table({
  tableName: 'roles_usuario',
  timestamps: false
})
export class RolUsuario extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_rol'
  })
  id!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true,
      isIn: [Object.values(PERMISOS_ROL).map(r => r.nombre)]
    }
  })
  nombre!: RolUsuarioNombre;

  // Relaciones
  @HasMany(() => Usuario, {
    foreignKey: 'id_rol',
    as: 'usuarios'
  })
  usuarios?: Usuario[];

  // M√©todos √∫tiles
  static getNombreRol(idRol: RolUsuarioId): string {
    return PERMISOS_ROL[idRol]?.nombre || 'Desconocido';
  }

  static getPermisos(idRol: RolUsuarioId): Permiso[] {
    return [...(PERMISOS_ROL[idRol]?.permisos || [])];
  }

  // M√©todo para verificar si un rol tiene un permiso espec√≠fico
  static tienePermiso(idRol: RolUsuarioId, permiso: Permiso): boolean {
    const permisos = PERMISOS_ROL[idRol]?.permisos;
    if (!permisos) return false;
    if (permisos.includes('*')) return true;
    return permisos.includes(permiso);
  }

  // M√©todo para verificar si un rol puede supervisar a otro
  static puedeSupervizar(rolSupervisor: RolUsuarioId, rolSubordinado: RolUsuarioId): boolean {
    const nivelSupervisor = PERMISOS_ROL[rolSupervisor]?.nivel;
    const nivelSubordinado = PERMISOS_ROL[rolSubordinado]?.nivel;
    if (!nivelSupervisor || !nivelSubordinado) return false;
    return nivelSupervisor < nivelSubordinado;
  }

  // M√©todo para obtener todos los permisos heredados
  static getPermisosHeredados(idRol: RolUsuarioId): Permiso[] {
    const permisosSet = new Set<Permiso>();
    const rolesHeredados = JERARQUIA_ROLES[idRol] || [];

    // Agregar permisos propios
    const permisosRol = PERMISOS_ROL[idRol]?.permisos || [];
    permisosRol.forEach(p => permisosSet.add(p));

    // Agregar permisos heredados
    rolesHeredados.forEach(rolHeredado => {
      const permisosHeredados = PERMISOS_ROL[rolHeredado]?.permisos || [];
      permisosHeredados.forEach(p => permisosSet.add(p));
    });

    return Array.from(permisosSet);
  }

  // M√©todo para obtener estad√≠sticas de uso
  static async getEstadisticasUso(): Promise<{
    usuariosPorRol: Record<RolUsuarioId, number>;
    porcentajes: Record<RolUsuarioId, number>;
    distribucionNiveles: Record<number, number>;
    rolesActivos: RolUsuarioId[];
  }> {
    const sequelize = new Sequelize('');
    const query = `
      SELECT id_rol, COUNT(*) as cantidad
      FROM usuarios
      GROUP BY id_rol
    `;

    const usuarios = await sequelize.query(query, {
      type: 'SELECT'
    }) as Array<{ id_rol: number; cantidad: string }>;

    const usuariosPorRol = {} as Record<RolUsuarioId, number>;
    const distribucionNiveles = {} as Record<number, number>;
    let total = 0;

    usuarios.forEach(u => {
      const idRol = u.id_rol as RolUsuarioId;
      const cantidad = parseInt(u.cantidad);
      usuariosPorRol[idRol] = cantidad;
      total += cantidad;

      const nivel = PERMISOS_ROL[idRol]?.nivel;
      if (nivel) {
        distribucionNiveles[nivel] = (distribucionNiveles[nivel] || 0) + cantidad;
      }
    });

    const porcentajes = {} as Record<RolUsuarioId, number>;
    Object.entries(usuariosPorRol).forEach(([rol, cantidad]) => {
      const rolId = parseInt(rol) as RolUsuarioId;
      porcentajes[rolId] = (cantidad / total) * 100;
    });

    const rolesActivos = Object.keys(usuariosPorRol)
      .map(r => parseInt(r) as RolUsuarioId)
      .sort((a, b) => usuariosPorRol[b] - usuariosPorRol[a]);

    return {
      usuariosPorRol,
      porcentajes,
      distribucionNiveles,
      rolesActivos
    };
  }
}

export default RolUsuario;import { Table, Column, Model, DataType, HasMany, Sequelize } from 'sequelize-typescript';
import { Op, QueryTypes } from 'sequelize';
import { Usuario } from '../usuario.model';
import { Cliente } from '../cliente.model';

// Tipo para los IDs de identificaci√≥n
export type TipoIdentificacionId = 1 | 2 | 3 | 4 | 5 | 6;

// Tipos de identificaci√≥n
export type TipoIdentificacionNombre = 
  'INE/IFE' | 
  'Pasaporte' | 
  'C√©dula Profesional' | 
  'Licencia de Conducir' | 
  'Cartilla Militar' |
  'Otro';

// Constantes para los tipos de identificaci√≥n
export const TIPOS_IDENTIFICACION = {
  INE: 1 as TipoIdentificacionId,
  PASAPORTE: 2 as TipoIdentificacionId,
  CEDULA: 3 as TipoIdentificacionId,
  LICENCIA: 4 as TipoIdentificacionId,
  CARTILLA: 5 as TipoIdentificacionId,
  OTRO: 6 as TipoIdentificacionId
} as const;

// Descripciones y reglas por tipo
export const REGLAS_IDENTIFICACION = {
  [TIPOS_IDENTIFICACION.INE]: {
    nombre: 'INE/IFE',
    descripcion: 'Credencial para votar emitida por el INE',
    formatoNumero: /^[A-Z]{6}[0-9]{8}[A-Z][0-9]{3}$/,
    vigenciaAnios: 10,
    requiereImagen: true
  },
  [TIPOS_IDENTIFICACION.PASAPORTE]: {
    nombre: 'Pasaporte',
    descripcion: 'Pasaporte mexicano vigente',
    formatoNumero: /^[A-Z][0-9]{8}$/,
    vigenciaAnios: 10,
    requiereImagen: true
  },
  [TIPOS_IDENTIFICACION.CEDULA]: {
    nombre: 'C√©dula Profesional',
    descripcion: 'C√©dula profesional emitida por la SEP',
    formatoNumero: /^[0-9]{7,8}$/,
    vigenciaAnios: null, // No expira
    requiereImagen: true
  },
  [TIPOS_IDENTIFICACION.LICENCIA]: {
    nombre: 'Licencia de Conducir',
    descripcion: 'Licencia de conducir vigente',
    formatoNumero: /^[A-Z0-9]{10,13}$/,
    vigenciaAnios: 3,
    requiereImagen: true
  },
  [TIPOS_IDENTIFICACION.CARTILLA]: {
    nombre: 'Cartilla Militar',
    descripcion: 'Cartilla del Servicio Militar Nacional',
    formatoNumero: /^[A-Z][0-9]{8}$/,
    vigenciaAnios: null, // No expira
    requiereImagen: true
  },
  [TIPOS_IDENTIFICACION.OTRO]: {
    nombre: 'Otro',
    descripcion: 'Otro tipo de identificaci√≥n oficial',
    formatoNumero: null,
    vigenciaAnios: null,
    requiereImagen: true
  }
} as const;

@Table({
  tableName: 'tipos_identificacion',
  timestamps: false
})
export class TipoIdentificacion extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_tipo_identificacion'
  })
  id!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true,
      isIn: [Object.values(REGLAS_IDENTIFICACION).map(r => r.nombre)]
    }
  })
  nombre!: TipoIdentificacionNombre;

  @Column({
    type: DataType.TEXT,
    allowNull: true
  })
  descripcion?: string;

  // Relaciones
  @HasMany(() => Usuario, {
    foreignKey: 'id_tipo_identificacion',
    as: 'usuarios'
  })
  usuarios?: Usuario[];

  @HasMany(() => Cliente, {
    foreignKey: 'id_tipo_identificacion',
    as: 'clientes'
  })
  clientes?: Cliente[];

  // M√©todos √∫tiles
  static getNombreTipo(idTipo: TipoIdentificacionId): string {
    return REGLAS_IDENTIFICACION[idTipo]?.nombre || 'Desconocido';
  }

  static getReglas(idTipo: TipoIdentificacionId) {
    return REGLAS_IDENTIFICACION[idTipo];
  }

  // M√©todo para validar el formato del n√∫mero de identificaci√≥n
  static validarFormato(idTipo: TipoIdentificacionId, numero: string): boolean {
    const reglas = REGLAS_IDENTIFICACION[idTipo];
    if (!reglas || !reglas.formatoNumero) return true; // Si no hay formato definido, se considera v√°lido
    return reglas.formatoNumero.test(numero);
  }

  // M√©todo para verificar vigencia
  static estaVigente(idTipo: TipoIdentificacionId, fechaEmision: Date): boolean {
    const reglas = REGLAS_IDENTIFICACION[idTipo];
    if (!reglas || !reglas.vigenciaAnios) return true; // Si no hay vigencia definida, se considera vigente
    
    const fechaVencimiento = new Date(fechaEmision);
    fechaVencimiento.setFullYear(fechaVencimiento.getFullYear() + reglas.vigenciaAnios);
    return fechaVencimiento > new Date();
  }

  // M√©todo para obtener estad√≠sticas de uso
  static async getEstadisticasUso(options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    totalPorTipo: Record<TipoIdentificacionId, number>;
    porcentajes: Record<TipoIdentificacionId, number>;
    masUsados: Array<{ id: TipoIdentificacionId; cantidad: number }>;
    distribucionClientes: Record<TipoIdentificacionId, number>;
    distribucionUsuarios: Record<TipoIdentificacionId, number>;
  }> {
    const sequelize = new Sequelize('');
    const where: any = {};
    
    if (options?.startDate && options?.endDate) {
      where.created_at = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    // Obtener estad√≠sticas de clientes
    const clientesQuery = `
      SELECT id_tipo_identificacion, COUNT(*) as cantidad
      FROM clientes
      ${where.created_at ? 'WHERE created_at BETWEEN :startDate AND :endDate' : ''}
      GROUP BY id_tipo_identificacion
    `;

    const usuariosQuery = `
      SELECT id_tipo_identificacion, COUNT(*) as cantidad
      FROM usuarios
      ${where.created_at ? 'WHERE created_at BETWEEN :startDate AND :endDate' : ''}
      GROUP BY id_tipo_identificacion
    `;

    const [clientes, usuarios] = await Promise.all([
      sequelize.query(clientesQuery, {
        replacements: where.created_at ? {
          startDate: options?.startDate,
          endDate: options?.endDate
        } : undefined,
        type: QueryTypes.SELECT
      }) as Promise<Array<{ id_tipo_identificacion: number; cantidad: string }>>,
      sequelize.query(usuariosQuery, {
        replacements: where.created_at ? {
          startDate: options?.startDate,
          endDate: options?.endDate
        } : undefined,
        type: QueryTypes.SELECT
      }) as Promise<Array<{ id_tipo_identificacion: number; cantidad: string }>>
    ]);

    const totalPorTipo = {} as Record<TipoIdentificacionId, number>;
    const distribucionClientes = {} as Record<TipoIdentificacionId, number>;
    const distribucionUsuarios = {} as Record<TipoIdentificacionId, number>;
    let total = 0;

    // Procesar estad√≠sticas de clientes
    clientes.forEach(c => {
      const idTipo = c.id_tipo_identificacion as TipoIdentificacionId;
      const cantidad = parseInt(c.cantidad);
      distribucionClientes[idTipo] = cantidad;
      totalPorTipo[idTipo] = (totalPorTipo[idTipo] || 0) + cantidad;
      total += cantidad;
    });

    // Procesar estad√≠sticas de usuarios
    usuarios.forEach(u => {
      const idTipo = u.id_tipo_identificacion as TipoIdentificacionId;
      const cantidad = parseInt(u.cantidad);
      distribucionUsuarios[idTipo] = cantidad;
      totalPorTipo[idTipo] = (totalPorTipo[idTipo] || 0) + cantidad;
      total += cantidad;
    });

    // Calcular porcentajes
    const porcentajes = {} as Record<TipoIdentificacionId, number>;
    Object.entries(totalPorTipo).forEach(([tipo, cantidad]) => {
      const tipoId = parseInt(tipo) as TipoIdentificacionId;
      porcentajes[tipoId] = (cantidad / total) * 100;
    });

    // Ordenar por m√°s usados
    const masUsados = Object.entries(totalPorTipo)
      .map(([id, cantidad]) => ({
        id: parseInt(id) as TipoIdentificacionId,
        cantidad
      }))
      .sort((a, b) => b.cantidad - a.cantidad);

    return {
      totalPorTipo,
      porcentajes,
      masUsados,
      distribucionClientes,
      distribucionUsuarios
    };
  }
}

export default TipoIdentificacion;import { Table, Column, Model, DataType, HasMany, Sequelize } from 'sequelize-typescript';
import { Op, QueryTypes } from 'sequelize';
import { Transaccion } from '../transaccion.model';

// Tipo para los IDs de transacci√≥n
export type TipoTransaccionId = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;

// Tipo para roles
export type RolUsuario = 'Administrador' | 'Ventas' | 'Finanzas';

// Constantes para los tipos de transacciones
export const TIPOS_TRANSACCION = {
  VENTA: 1 as TipoTransaccionId,
  APARTADO: 2 as TipoTransaccionId,
  PAGO_CREDITO: 3 as TipoTransaccionId,
  TRASPASO: 4 as TipoTransaccionId,
  CAMBIO: 5 as TipoTransaccionId,
  CONSIGNACION: 6 as TipoTransaccionId,
  DEVOLUCION: 7 as TipoTransaccionId,
  CANCELACION: 8 as TipoTransaccionId
} as const;

// Descripciones de los tipos de transacci√≥n
export const DESCRIPCIONES_TIPO = {
  1: 'Venta directa de veh√≠culo',
  2: 'Apartado de veh√≠culo con anticipo',
  3: 'Pago de cr√©dito automotriz',
  4: 'Traspaso de propiedad del veh√≠culo',
  5: 'Cambio o permuta de veh√≠culos',
  6: 'Consignaci√≥n de veh√≠culo',
  7: 'Devoluci√≥n de veh√≠culo',
  8: 'Cancelaci√≥n de transacci√≥n'
} satisfies Record<TipoTransaccionId, string>;

// Grupos de tipos relacionados
export const GRUPOS_TIPO: Record<string, TipoTransaccionId[]> = {
  VENTAS: [TIPOS_TRANSACCION.VENTA, TIPOS_TRANSACCION.APARTADO],
  CREDITOS: [TIPOS_TRANSACCION.PAGO_CREDITO],
  CAMBIOS: [TIPOS_TRANSACCION.TRASPASO, TIPOS_TRANSACCION.CAMBIO],
  CONSIGNACIONES: [TIPOS_TRANSACCION.CONSIGNACION],
  CANCELACIONES: [TIPOS_TRANSACCION.DEVOLUCION, TIPOS_TRANSACCION.CANCELACION]
};

// Roles que pueden realizar cada tipo de transacci√≥n
export const PERMISOS_TIPO = {
  1: ['Administrador', 'Ventas'] as RolUsuario[],
  2: ['Administrador', 'Ventas'] as RolUsuario[],
  3: ['Administrador', 'Finanzas'] as RolUsuario[],
  4: ['Administrador'] as RolUsuario[],
  5: ['Administrador', 'Ventas'] as RolUsuario[],
  6: ['Administrador', 'Ventas'] as RolUsuario[],
  7: ['Administrador'] as RolUsuario[],
  8: ['Administrador'] as RolUsuario[]
} satisfies Record<TipoTransaccionId, RolUsuario[]>;

@Table({
  tableName: 'tipos_transaccion',
  timestamps: false
})
export class TipoTransaccion extends Model {
  @Column({
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'id_tipo_transaccion'
  })
  id!: number;

  @Column({
    type: DataType.STRING(50),
    allowNull: false,
    validate: {
      notEmpty: true,
      isIn: [Object.values(DESCRIPCIONES_TIPO)]
    }
  })
  nombre!: string;

  // Relaciones
  @HasMany(() => Transaccion, {
    foreignKey: 'id_tipo_transaccion',
    as: 'transacciones'
  })
  transacciones?: Transaccion[];

  // M√©todos de validaci√≥n
  static isPagoCredito(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.PAGO_CREDITO;
  }

  static isVenta(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.VENTA;
  }

  static isApartado(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.APARTADO;
  }

  static isTraspaso(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.TRASPASO;
  }

  static isCambio(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.CAMBIO;
  }

  static isConsignacion(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.CONSIGNACION;
  }

  static isDevolucion(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.DEVOLUCION;
  }

  static isCancelacion(idTipo: number): boolean {
    return idTipo === TIPOS_TRANSACCION.CANCELACION;
  }

  // M√©todo para obtener el nombre del tipo
  static getNombreTipo(idTipo: TipoTransaccionId): string {
    return DESCRIPCIONES_TIPO[idTipo] || 'Desconocido';
  }

  // M√©todo para validar si un ID de tipo es v√°lido
  static isValidTipo(idTipo: number): idTipo is TipoTransaccionId {
    return Object.values(TIPOS_TRANSACCION).includes(idTipo as TipoTransaccionId);
  }

  // M√©todo para convertir un n√∫mero a TipoTransaccionId
  static toTipoTransaccionId(idTipo: number): TipoTransaccionId | null {
    return this.isValidTipo(idTipo) ? idTipo : null;
  }

  // M√©todo para verificar permisos
  static tienePermiso(idTipo: TipoTransaccionId, rol: RolUsuario): boolean {
    return PERMISOS_TIPO[idTipo]?.includes(rol) || false;
  }

  // M√©todo para obtener tipos relacionados
  static getTiposRelacionados(idTipo: TipoTransaccionId): TipoTransaccionId[] {
    const grupoEncontrado = Object.values(GRUPOS_TIPO).find(grupo => 
      grupo.includes(idTipo)
    );
    return grupoEncontrado ? [...grupoEncontrado] : [];
  }

  // M√©todo para obtener estad√≠sticas de uso
  static async getEstadisticasUso(options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    totalPorTipo: Record<TipoTransaccionId, number>;
    porcentajes: Record<TipoTransaccionId, number>;
    tendencias: Record<TipoTransaccionId, 'aumento' | 'disminuci√≥n' | 'estable'>;
    tiposMasUsados: Array<{ id: TipoTransaccionId; cantidad: number }>;
  }> {
    const sequelize = new Sequelize('');
    const where: any = {};
    
    if (options?.startDate && options?.endDate) {
      where.fecha = {
        [Op.between]: [options.startDate, options.endDate]
      };
    }

    const query = `
      SELECT id_tipo_transaccion, COUNT(*) as cantidad
      FROM transacciones
      ${where.fecha ? `WHERE fecha BETWEEN :startDate AND :endDate` : ''}
      GROUP BY id_tipo_transaccion
    `;

    const transacciones = await sequelize.query(query, {
      replacements: where.fecha ? {
        startDate: options?.startDate,
        endDate: options?.endDate
      } : undefined,
      type: QueryTypes.SELECT
    }) as Array<{ id_tipo_transaccion: number; cantidad: string }>;

    const totalPorTipo = {} as Record<TipoTransaccionId, number>;
    let total = 0;

    transacciones.forEach(t => {
      if (this.isValidTipo(t.id_tipo_transaccion)) {
        const cantidad = parseInt(t.cantidad);
        totalPorTipo[t.id_tipo_transaccion] = cantidad;
        total += cantidad;
      }
    });

    const porcentajes = {} as Record<TipoTransaccionId, number>;
    Object.entries(totalPorTipo).forEach(([tipo, cantidad]) => {
      const tipoId = parseInt(tipo) as TipoTransaccionId;
      if (this.isValidTipo(tipoId)) {
        porcentajes[tipoId] = (cantidad / total) * 100;
      }
    });

    // Calcular tendencias
    const tendencias = {} as Record<TipoTransaccionId, 'aumento' | 'disminuci√≥n' | 'estable'>;
    if (options?.startDate && options?.endDate) {
      const mitad = new Date((options.startDate.getTime() + options.endDate.getTime()) / 2);
      
      const [primerasMitad, segundasMitad] = await Promise.all([
        sequelize.query(
          `SELECT id_tipo_transaccion, COUNT(*) as cantidad
           FROM transacciones
           WHERE fecha < :fecha
           GROUP BY id_tipo_transaccion`,
          {
            replacements: { fecha: mitad },
            type: QueryTypes.SELECT
          }
        ) as Promise<Array<{ id_tipo_transaccion: number; cantidad: string }>>,
        sequelize.query(
          `SELECT id_tipo_transaccion, COUNT(*) as cantidad
           FROM transacciones
           WHERE fecha >= :fecha
           GROUP BY id_tipo_transaccion`,
          {
            replacements: { fecha: mitad },
            type: QueryTypes.SELECT
          }
        ) as Promise<Array<{ id_tipo_transaccion: number; cantidad: string }>>
      ]);

      const cantidadesPrimeras = {} as Record<TipoTransaccionId, number>;
      const cantidadesSegundas = {} as Record<TipoTransaccionId, number>;

      primerasMitad.forEach(t => {
        if (this.isValidTipo(t.id_tipo_transaccion)) {
          cantidadesPrimeras[t.id_tipo_transaccion] = parseInt(t.cantidad);
        }
      });

      segundasMitad.forEach(t => {
        if (this.isValidTipo(t.id_tipo_transaccion)) {
          cantidadesSegundas[t.id_tipo_transaccion] = parseInt(t.cantidad);
        }
      });

      Object.keys(totalPorTipo).forEach(tipo => {
        const tipoId = parseInt(tipo) as TipoTransaccionId;
        if (this.isValidTipo(tipoId)) {
          const primera = cantidadesPrimeras[tipoId] || 0;
          const segunda = cantidadesSegundas[tipoId] || 0;
          const diferencia = segunda - primera;

          if (diferencia > primera * 0.1) tendencias[tipoId] = 'aumento';
          else if (diferencia < -primera * 0.1) tendencias[tipoId] = 'disminuci√≥n';
          else tendencias[tipoId] = 'estable';
        }
      });
    }

    const tiposMasUsados = Object.entries(totalPorTipo)
      .map(([id, cantidad]) => {
        const tipoId = parseInt(id) as TipoTransaccionId;
        return this.isValidTipo(tipoId) ? { 
          id: tipoId, 
          cantidad 
        } : null;
      })
      .filter((item): item is { id: TipoTransaccionId; cantidad: number } => item !== null)
      .sort((a, b) => b.cantidad - a.cantidad);

    return {
      totalPorTipo,
      porcentajes,
      tendencias,
      tiposMasUsados
    };
  }
}

export default TipoTransaccion;import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import path from 'path';
import { verificarToken } from './src/middlewares/auth.middleware';
import usuarioRoutes from './src/routes/usuario.routes';
import citaRoutes from './src/routes/cita.routes';
import clienteRoutes from './src/routes/cliente.routes';
import creditoRoutes from './src/routes/credito.routes';
import documentoRoutes from './src/routes/documento.routes';
import nominaRoutes from './src/routes/nomina.routes';
import transaccionRoutes from './src/routes/transaccion.routes';
import vehiculoRoutes from './src/routes/vehiculo.routes';
import ventaRoutes from './src/routes/venta.routes';
import empleadoRoutes from './src/routes/empleado.routes';
import scannerRoutes from './src/routes/scanner.routes';

// Importar rutas de cat√°logos
import tipoTransaccionRoutes from './src/routes/catalogs/tipo-transaccion.routes';
import rolUsuarioRoutes from './src/routes/catalogs/rol-usuario.routes';
import tipoIdentificacionRoutes from './src/routes/catalogs/tipo-identificacion.routes';

// Configurar variables de entorno
dotenv.config();

const app = express();

// Configurar Express para confiar en proxies
app.set('trust proxy', function (ip: string) {
  // Confiar en todas las IPs privadas y localhost
  if (ip === 'localhost' || ip === '127.0.0.1' || ip === '::1') return true;
  // Confiar en IPs de red local
  if (ip.startsWith('10.') || ip.startsWith('192.168.') || /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip)) return true;
  // No confiar en otras IPs
  return false;
});

// Middleware para obtener la IP real
app.use((req, _res, next) => {
  // Obtener la IP real del cliente
  let ip = '0.0.0.0';
  
  console.log('üîç Informaci√≥n de la solicitud:', {
    'headers': {
      'x-forwarded-for': req.headers['x-forwarded-for'],
      'x-real-ip': req.headers['x-real-ip'],
      'x-client-ip': req.headers['x-client-ip'],
      'forwarded': req.headers['forwarded'],
      'via': req.headers['via']
    },
    'connection': {
      'remoteAddress': req.connection.remoteAddress,
      'socketAddress': req.socket.remoteAddress
    },
    'express': {
      'ip': req.ip,
      'ips': req.ips
    }
  });

  // Intentar obtener la IP de diferentes fuentes en orden de prioridad
  if (req.ips && req.ips.length > 0) {
    // Si hay IPs en la cadena de proxy, tomar la primera (la del cliente original)
    ip = req.ips[0];
    console.log('‚úÖ IP obtenida de req.ips:', ip);
  } else if (req.headers['x-forwarded-for']) {
    // Si hay un header X-Forwarded-For, tomar la primera IP
    const forwardedFor = req.headers['x-forwarded-for'];
    ip = Array.isArray(forwardedFor) ? forwardedFor[0] : forwardedFor.split(',')[0];
    console.log('‚úÖ IP obtenida de x-forwarded-for:', ip);
  } else if (req.headers['x-real-ip']) {
    // Si hay un header X-Real-IP, usarlo
    const realIp = req.headers['x-real-ip'];
    ip = Array.isArray(realIp) ? realIp[0] : realIp;
    console.log('‚úÖ IP obtenida de x-real-ip:', ip);
  } else if (req.ip) {
    // Usar la IP que Express ha determinado
    ip = req.ip;
    console.log('‚úÖ IP obtenida de req.ip:', ip);
  } else if (req.connection.remoteAddress) {
    // √öltimo recurso: usar la direcci√≥n remota de la conexi√≥n
    ip = req.connection.remoteAddress;
    console.log('‚úÖ IP obtenida de connection.remoteAddress:', ip);
  }

  // Limpiar la IP
  ip = ip.replace(/^::ffff:/, '').trim();
  
  // Validar que la IP sea v√°lida
  if (!/^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(ip) && ip !== '::1') {
    console.log('‚ö†Ô∏è IP no v√°lida, usando default:', ip);
    ip = '0.0.0.0';
  }

  // Almacenar la IP real en el objeto request
  req.realIP = ip;
  console.log('‚úÖ IP final almacenada:', req.realIP);
  next();
});

// Middlewares
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configurar el directorio de uploads como est√°tico
const uploadsDir = path.join(process.cwd(), 'uploads');
app.use('/uploads', express.static(uploadsDir));

// Aplicar verificaci√≥n de token a todas las rutas excepto /api/usuarios/login y /uploads
app.use((req, res, next) => {
  // Excluir la ruta de login y uploads de la verificaci√≥n de token
  if (req.path === '/api/usuarios/login' || req.path.startsWith('/uploads/')) {
    return next();
  }
  verificarToken(req, res, next);
});

// Rutas principales
app.use('/api/usuarios', usuarioRoutes);
app.use('/api/citas', citaRoutes);
app.use('/api/clientes', clienteRoutes);
app.use('/api/creditos', creditoRoutes);
app.use('/api/documentos', documentoRoutes);
app.use('/api/nominas', nominaRoutes);
app.use('/api/transacciones', transaccionRoutes);
app.use('/api/vehiculos', vehiculoRoutes);
app.use('/api/ventas', ventaRoutes);
app.use('/api/empleados', empleadoRoutes);
app.use('/api/scanner', scannerRoutes);
app.use('/api/configure', scannerRoutes);
app.use('/api/status', scannerRoutes);

// Rutas de cat√°logos
app.use('/api/catalogs/tipos-transaccion', tipoTransaccionRoutes);
app.use('/api/catalogs/roles-usuario', rolUsuarioRoutes);
app.use('/api/catalogs/tipos-identificacion', tipoIdentificacionRoutes);

// Ruta de prueba (tambi√©n protegida)
app.get('/', (req, res) => {
  res.json({ message: 'API de Cliqueanet funcionando correctamente' });
});

// Extender el tipo Request de Express
declare global {
  namespace Express {
    interface Request {
      realIP: string;
    }
  }
}

export default app;import app from '../app';
import sequelize from './config/database';
import dotenv from 'dotenv';
import { initializeAssociations } from './models/modelAssociations';

// Configuraci√≥n de variables de entorno
dotenv.config();

const port = process.env.PORT || 3001;

// Funci√≥n para inicializar el servidor
const startServer = async () => {
  try {
    // Verificar conexi√≥n a la base de datos
    await sequelize.authenticate();
    console.log('Conexi√≥n a la base de datos establecida correctamente.');

    // Inicializar asociaciones de modelos
    initializeAssociations();
    console.log('Modelos cargados correctamente.');
    console.log('Asociaciones de modelos inicializadas correctamente.');

    // Sincronizar modelos con la base de datos (no forzar en producci√≥n)
    if (process.env.NODE_ENV !== 'production') {
      await sequelize.sync({ alter: true, force: false });
      console.log('Modelos sincronizados con la base de datos.');
    }

    // Iniciar el servidor
    app.listen(port, () => {
      console.log(`Servidor corriendo en http://localhost:${port}`);
    });
  } catch (error) {
    console.error('Error al iniciar el servidor:', error);
    process.exit(1);
  }
};

// Manejo de errores no capturados
process.on('unhandledRejection', (error) => {
  console.error('Error no manejado:', error);
  process.exit(1);
});

// Iniciar el servidor
startServer();